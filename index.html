<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="Steven的博客">
<meta property="og:url" content="http://nonumber1989.github.io/index.html">
<meta property="og:site_name" content="Steven的博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Steven的博客">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="http://nonumber1989.github.io/"/>


  <title> Steven的博客 </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Steven的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/04/microservices/microservices/" itemprop="url">
                  Chris Richardson 微服务系列文章 翻译
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-01-04T13:36:23+08:00" content="2017-01-04">
              2017-01-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/microservice/" itemprop="url" rel="index">
                    <span itemprop="name">microservice</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  2017年的元旦，经过同事介绍开始阅读 nginx blog上的大神<strong>Chris Richardson</strong>发布的七篇针对微服务的文章，刚好决定在新年伊始，做一点技术上的积累，那么就从翻译开始吧！ 这是我第一次翻译外文博客，难免有一些含糊不清的地方，希望各位看官轻喷并帮助我纠正，针对文章中的一些问题 我也将会提出自己的疑问（一开始就是因为有疑问才看的文章，摔！）</p>
<h1 id="原链接地址"><a href="#原链接地址" class="headerlink" title="原链接地址"></a>原链接地址</h1><ol>
<li><a href="https://www.nginx.com/blog/introduction-to-microservices/" target="_blank" rel="external"><em>Introduction to Microservices</em></a></li>
<li><a href="https://www.nginx.com/blog/building-microservices-using-an-api-gateway/?utm_source=introduction-to-microservices&amp;utm_medium=blog&amp;utm_campaign=Microservices" target="_blank" rel="external"><em>Building Microservices: Using an API Gateway</em></a></li>
<li><a href="https://www.nginx.com/blog/building-microservices-inter-process-communication/?utm_source=introduction-to-microservices&amp;utm_medium=blog&amp;utm_campaign=Microservices" target="_blank" rel="external"><em>Building Microservices: Inter-Process Communication in a Microservices Architecture</em></a></li>
<li><a href="https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture/?utm_source=introduction-to-microservices&amp;utm_medium=blog&amp;utm_campaign=Microservices" target="_blank" rel="external"><em>Service Discovery in a Microservices Architecture</em></a></li>
<li><a href="https://www.nginx.com/blog/event-driven-data-management-microservices/?utm_source=introduction-to-microservices&amp;utm_medium=blog&amp;utm_campaign=Microservices" target="_blank" rel="external"><em>Event-Driven Data Management for Microservices</em></a></li>
<li><a href="https://www.nginx.com/blog/deploying-microservices/?utm_source=introduction-to-microservices&amp;utm_medium=blog&amp;utm_campaign=Microservices" target="_blank" rel="external"><em>Choosing a Microservices Deployment Strategy</em></a></li>
<li><a href="https://www.nginx.com/blog/refactoring-a-monolith-into-microservices/?utm_source=introduction-to-microservices&amp;utm_medium=blog&amp;utm_campaign=Microservices" target="_blank" rel="external"><em>Refactoring a Monolith into Microservices</em></a></li>
</ol>
<h1 id="译文链接"><a href="#译文链接" class="headerlink" title="译文链接"></a>译文链接</h1><ol>
<li><em><a href="http://www.jianshu.com/p/8d2cfa1fa633" target="_blank" rel="external">微服务介绍</a></em></li>
<li><em><a href="http://www.jianshu.com/p/9e90b2a5df7b" target="_blank" rel="external">构建微服务之使用API网关</a></em></li>
<li><em><a href="http://www.jianshu.com/p/9c03081bc0d9" target="_blank" rel="external">构建微服务之:微服务架构中的进程间通信</a></em></li>
<li><em><a href="http://www.jianshu.com/p/1bf9a46efe7a" target="_blank" rel="external">微服务中的服务发现</a></em></li>
<li><em><a href="http://www.jianshu.com/p/9a440c5ea1db" target="_blank" rel="external">微服务之事件驱动的数据管理</a></em></li>
<li><em><a href="http://www.jianshu.com/p/31c2a5a8b764" target="_blank" rel="external">选择一种微服务部署策略</a></em></li>
<li><em><a href="http://www.jianshu.com/p/29f4d788e3bb" target="_blank" rel="external">重构单体应用到微服务</a></em></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/04/microservices/Service Discovery in a Microservices Architecture/" itemprop="url">
                  微服务中的服务发现
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-01-04T13:36:23+08:00" content="2017-01-04">
              2017-01-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/microservice/" itemprop="url" rel="index">
                    <span itemprop="name">microservice</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/04/microservices/Refactoring a Monolith into Microservices/" itemprop="url">
                  重构单体应用到微服务
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-01-04T13:36:23+08:00" content="2017-01-04">
              2017-01-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/microservice/" itemprop="url" rel="index">
                    <span itemprop="name">microservice</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/04/microservices/Introduction to Microservices/" itemprop="url">
                  微服务介绍
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-01-04T13:36:23+08:00" content="2017-01-04">
              2017-01-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/microservice/" itemprop="url" rel="index">
                    <span itemprop="name">microservice</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>原文链接:<a href="https://www.nginx.com/blog/introduction-to-microservices/" target="_blank" rel="external"><em>Introduction to Microservices</em></a></strong></p>
<ol>
<li><em>微服务介绍(本文)</em></li>
<li><em><a href="http://www.jianshu.com/p/9e90b2a5df7b" target="_blank" rel="external">构建微服务之使用API网关</a></em></li>
<li><em><a href="http://www.jianshu.com/p/9c03081bc0d9" target="_blank" rel="external">构建微服务之:微服务架构中的进程内通信</a></em></li>
<li><em><a href="http://www.jianshu.com/p/1bf9a46efe7a" target="_blank" rel="external">微服务中的服务发现</a></em></li>
<li><em><a href="http://www.jianshu.com/p/9a440c5ea1db" target="_blank" rel="external">微服务之事件驱动的数据管理</a></em></li>
<li><em><a href="http://www.jianshu.com/p/31c2a5a8b764" target="_blank" rel="external">选择一种微服务部署策略</a></em></li>
<li><em><a href="http://www.jianshu.com/p/29f4d788e3bb" target="_blank" rel="external">重构单体应用到微服务</a></em></li>
</ol>
<p>微服务现在受到了大量的关注︰ 文章、 博客、 社交媒体和学术会议上的讨论都能看到该词汇的身影。微服务正迅速走向 Gartner Hype cycle 所指的快速发展期。同时，软件社区的一些怀疑论者指出微服务并不是什么新鲜玩意儿。这些唱反调的人说微服务和SOA概念并没有什么不同，旧瓶装新酒而已，顺势炒炒新概念。然而，不管说是夸大也好，怀疑也好，微服务架构模式应用在敏捷开发和交付复杂的企业应用程序的时候还是有巨大优势的 。</p>
<p>这篇博客是设计、构建和部署微服务七篇博客系列之一。通过该文章将学到一些微服务的方法，还有微服务架构与传统的整体式架构模式的比较。本系列将介绍微服务架构的各种元素，并揭示该架构模式的各种优点与缺点，以此来指导微服务是否适合您的项目，以及如何运用该模式。</p>
<p>让我们首先看看为什么你应该考虑使用微服务。</p>
<h2 id="构建整体式应用"><a href="#构建整体式应用" class="headerlink" title="构建整体式应用"></a>构建整体式应用</h2><p>假设现在我们为了与Uber和Hailo竞争来构建一个全新的出租车品牌<strong>taxi-hailing</strong>:经过一系列的预备会议和需求收集，我们决定无论是人工撸还是用Rails，Spring Boot，Play，或Maven之类工具生成也好，最终要创建一个全新的应用！应用应该有如下图六边形一样的模块结构</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3912920-d319c7769ff1e518.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>应用程序的核心是业务逻辑，它了定义服务、 领域对象和事件模块。围绕核心是接口与外部世界的适配器。适配器的例子包括数据库访问组件、 生产消息和消费消息的消息传递组件以及暴露API或实现用户界面的 web 组件。</p>
<p>尽管在逻辑上模块化，整个应用还是做为一个巨大的整体进行打包和部署的。而且模块的结构往往与选择的编程语言和框架紧密相关。 举个栗子： 多数java程序打成war包部署到Tomcat 、Jetty等应用服务器中；还有一部分被打成自包含的jar包（Spring Boot支持把jetty或者tomcat包进去，以main为入口启动应用）； 同样的，Rails 和 Node.js 应用直接以目录结构的方式部署.</p>
<p>这种风格开发的应用是非常常见的。我们的IDE和工具致力于构建这样的单一应用，所以我们开发起来也感觉到简单；此类应用测试起来也很方便，你可以很简单的启动这个应用，采用selenium测试UI去完成端到端的测试；单体应用部署起来也不难，把包一拷贝扔服务器里就妥了， 如果要扩展应用，只需要在负载均衡器后面跑多个相同的应用就可以了。工程的初期呢，这个方法工作的还是不错的！</p>
<h2 id="迈向单体的地狱"><a href="#迈向单体的地狱" class="headerlink" title="迈向单体的地狱"></a>迈向单体的地狱</h2><p>很不幸的是，这种方式还是有巨大的局限性的.。一个成功的应用总会随着时间逐步成长并变得巨大起来。每个敏捷Sprint周期，开发者会实现更多的功能，当然这就意味着又添加了很多行代码。几年之后你会发现，当年你写的那个简单的小小的应用居然变成一个巨大的单体怪物。举一个比较极端的例子吧：最近我和一个开发者聊天，他正在写一个工具来分析数百万行代码的巨大应用中的上千个jar的依赖关系。别的不说，写出这么巨大的怪物肯定花费了很多程序员几年的时间。</p>
<p>一旦应用变成了巨大复杂的单体，那你的开发团队将痛苦不堪！敏捷开发和交付的一些愿景在这个庞然大物面前都会受挫。最主要的问题就是这玩意儿现在太复杂了！复杂到很难有某个程序员能完全理解它！导致结果就是，正确的修个bug、做个新功能变的费时又费力。更可恨的是，这是一个恶性循环的过程，应用正在逐步的‘死去’ 。如果你的代码库别人都理解不了，那么对代码做点正确的改动是很难的，最终这个怪物更加的可怕更加的难以理解，纠结！</p>
<p>应用程序的规模大了也会拖慢程序的开发： 程序越大，启动越慢！调查显示一些程序员说他们启动程序要12分钟，我个人还听过有的应用启动要40分钟！程序员开发过程需要周期性的重启应用，这样就浪费了很多时间，效率自然也很低下，不能忍！</p>
<p>巨大、复杂的单体应用还是持续交付的巨大障碍。现在SaaS应用的宗旨是如果有改动能够每天部署多次。单体应用的中某部分的改动需要需要重新部署整个应用，这样的话持续交付是相当困难的。前面也讲了，启动一次就要那么久 ！另外，改动造成的影响也不是很好被理解，需要大量的手工测试去保证，这样的话持续交付更是难上加难了！</p>
<p>单体应用在多个模块对资源需求上有冲突时很难进行扩展。比如：一个新模块可能实现了CPU密集型的图片处理逻辑,更适合部署到Amazon EC2 Compute Optimized instances。另一个模块可能需要一个内存数据库，更适合使用EC2 Memory-optimized instances。然而，这些模块必须被一起部署的话，选择硬件的时候就要好好折中一下喽。</p>
<p>单体应用的另一个问题是稳定性：因为所有的模块都跑在同一进程之中，某模块中的bug，比如内存泄漏是可能拖垮整个应用的！更重要的是，因为负载均衡后面的所有的应用是一样的，bug还可能影响整个应用的可用性！</p>
<p>最后重要的一点：单体应用很难拥抱新的框架和编程语言。假设你有2百万行用XYZ框架写的代码，如果用ABC框架重写它将会耗费巨大的时间和金钱！哪怕大家都知道用新框架更适合一些（摊手）。这样导致的结果是，在尝试转换新框架新技术的时候存在巨大的障碍，我们不得不继续在选型之初定好的技术架构上前行（哭脸）。</p>
<p>最后总结下吧，你从拥有一个业务清晰，几个程序员都明白的小程序，逐步的变成了一个可怕的单体应用。回首看这个应用是采用了过时的、效率低下的技术来写的（毕竟技术在进步，抱着老东西闷头陶醉不是什么好事情）！别的不说，招聘都费劲呐！这个单体应用变的难以扩展、变得极不稳定，想敏捷开发？想持续交付？ 恐怕只能呵呵了。</p>
<p>面对这些，你能做点什么呢？</p>
<h2 id="微服务-–-处理这些复杂问题！"><a href="#微服务-–-处理这些复杂问题！" class="headerlink" title="微服务 – 处理这些复杂问题！"></a>微服务 – 处理这些复杂问题！</h2><p>很多机构，比如Amazon、eBay、Netflix，已经开始通过拥抱微服务架构去解决上述的问题了。她们不再去构建一个可怕的单体应用，而是拆分成多个更小的、相互连接的微服务！</p>
<p>服务通常实现了一系列相互独立的功能或特性，比如订单管理、客户管理等等。每一个微服务都具有自身业务逻辑以及各种适配器构成的六角形架构模式，都是一个迷你的小应用。有的微服务会暴露API供其他微服务和客户消费，其他微服务则可能实现Web UI。运行时，每一个实例通常是云平台的一个VM或者一个Docker容器。</p>
<p>下面是对上述老架构的一个拆分：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3912920-9762019e56935c8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>应用的每个功能区域限制都以微服务的方式来实现了，此外整个应用被拆分成一系列更小的web应用（比如乘客管理、司机管理）。拆分之后更加方便的为特殊用户、设备或者特殊用例进行部署。</p>
<p>每一个后端服务暴露REST API，绝大部分服务也会消费其他服务提供的API。比如，司机管理服务会使用通知服务告知空闲的司机潜在的行程（来生意了，接单！）；还有UI 服务会调用其他服务后渲染web页面。服务之间也会使用异步的，基于消息的通信模式，服务内的通信将会在后面的文章详述。</p>
<p>一些REST API 也会暴露给移动端设备方便司机和乘客的使用。当然，这些应用不会直接访问后端各个微服务 ，而是通过一个协调者<strong>API网关</strong>来访问的。 API网关的职责有负载均衡、缓存、访问控制、API计费、监控···，这些事情使用NGINX就OK啦。后面的文章将会讲述API网关的细节。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3912920-edd018002c577cff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>微服务架构模式很契合上图的Y轴扩展方式，上图X轴的扩展表示横向扩展应用，一般就是负载均衡器后面部署几个相同的应用。Z轴扩展表示数据分区,将请求路由到特定的服务器上（比如数据库分库分表，根据主键访问到用户记录对应的数据库）。</p>
<p>应用一般都会三个维度去扩展。Y轴正是按照我们第一节讲到的，把单体应用拆分为微服务，运行时呢，为了某个服务达到高吞吐和高可用性，可以采用负载均衡，也就是X轴扩展了，特殊应用也会使用Z轴扩展来切分服务。下面的图展示了行程管理采用Docker镜像部署到Amazon EC2的情况：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3912920-2d3f5e1b1c954c35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>运行时，行程管理由多个服务实例组成。每个应用实例实际是一个Docker容器。为了达到高可用，容器会跑在多个云平台VM上，服务实例之前是NGINX这样的负载均衡器来分发请求，负载均衡器也会关注比如缓存、权限访问、服务计费、监控等事宜。</p>
<p>微服务架构模式极大的影响应用和数据库之间的关系。每个微服务都会有自己的数据库Schema，而不是和其他服务共享一套数据库Shcema。另一个角度看，这种方式对于以往企业级范围的数据模型来讲是很奇怪的，另外，微服务这么搞会造成数据冗余。然而，如果你想从微服务架构获益，那么每个微服务一个数据Schema是很有必要的，因为微服务提倡的就是松耦合啊，下面的图展示了微服务架构下应用的数据架构：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3912920-609da44e77622fea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>每个微服务都有自己的数据库，而且每个服务还能选择适合自己需求的数据库，这就是所谓的多态型持久化架构。比如，司机如果需要查找附近的潜在乘客，那就必须要使用支持高效地理位置查询的数据库。</p>
<p>表面上看微服务和SOA架构很相似，两种架构都倡导由一系列的服务组成。我们可以把微服务架构模式当成是没有商业web service规范（WS规范咯）以及ESB等打包的套件约束的SOA。基于微服务架构的应用更倾向于简单的、轻量级的REST协议而不是老旧的WS，当然，微服务也会避免去使用笨重的ESB套件而更喜欢去实现一些ESB部分功能的轻量级工具（不要捆绑，不要全家桶！），微服务架构模式也避免SOA中诸如规范化Schema的定义。</p>
<h2 id="微服务的优势"><a href="#微服务的优势" class="headerlink" title="微服务的优势"></a>微服务的优势</h2><p>微服务架构模式有很多重要的优势。首先，通过把可怕巨大的单体拆分为一系列的服务解决了单体复杂度问题， 拆分后整体功能数量并没有变化，但是应用现在变成了多个方便管理的小应用，每个服务都有一个定义良好的服务边界，通过RPC方式或消息驱动暴露API。微服务架构模式解决了单体应用代码库在实践中极难模块化的难题，拆分后的微服务能够更快的部署，更易理解和维护！</p>
<p>第二，拆分后的服务可以被专注于某部分服务的团队独立开发。程序员可以基于API约定前提下自由选择合适的技术，当然，很多机构为了避免技术选择混乱也会限制技术的选项。因此，自由意味着程序员可以不再局限于项目初期选择的技术了（撒花）！开始写一个新的微服务的时候，开发者可以使用一些当下流行的技术，更重要的是，因为每个服务现在拆分的很小，使用现有技术重写老的服务成为可能！</p>
<p>第三，微服务架构模式使得独立部署成为可能，开发者不用再忙碌于协调其他模块的变化再去部署（单体应用，改一个部分可能对其他部分影响，某个更改可能涉及多个模块的协调），微服务的更改可以在测试后尽快的被部署。比如，UI组可以进行A/B测试并且快速迭代而不用等待整个应用部署。微服务架构模式使得持续部署成为可能！</p>
<p>最后，微服务架构模式使得每个服务可以独立的扩展。我们可以针对某些有容量和可用性要求的微服务进行扩展，为需要的服务部署多个实例而不是复制多个单体去折中获得某项提升！更重要的是，我们可以针对服务需求使用最合适的硬件资源。比如，我们可以把CPU密集型的图片处理服务部署到EC2 Compute Optimized instances，部署内存数据库相关的服务到EC2 Memory-optimized instances。</p>
<h2 id="微服务的劣势"><a href="#微服务的劣势" class="headerlink" title="微服务的劣势"></a>微服务的劣势</h2><p>正如Fred 30年前的书中所说,“没有银弹！”。和其他技术一样，微服务架构也有其劣势 。劣势之一就是它的名字（捂脸），微服务这个词过分强调了服务的尺寸，实际上还真有几个开发者号召大家写10-100行代码的‘微服务’（这应该不太可能吧）！然而微服务更想表达的是一种工具和途径，微并不是最终的目标（为微服务而微服务，敲响警钟），微服务是为了便利敏捷开发和部署而去有效的拆分应用。</p>
<p>微服务另一个劣势是因为从单体应用拆分为分布式系统带来的复杂。开发者需要选择或者实现基于消息或者RPC模式的进程间通讯机制，另外开发者也要写额外的代码去处理对于目的服务请求可能存在的请求缓慢或者请求不可用导致的部分失败问题。分布式系统可不是什么火箭科学，它可比单体应用中模块间通过语言层面或者进程内调用复杂的多了！</p>
<p>微服务另一个挑战就是拆分数据库架构。一个逻辑事务更新多个业务记录是很常见的事情，单体应用实现该事务是比较简单的，毕竟大家使用一个数据库。然而在微服务架构中，你必须要更新多个服务的多个数据库。一般不会使用分布式事务，不仅仅是因为CAP理论，还因为一些流行的NoSQL数据库和Message Queue系统压根也不支持（摊手）。最后还得绕回最终一致性方案，这个方案对开发者来讲也是略有挑战的（实际上我看这个系列的文章并且开始翻译也是因为实际中遇到了这个问题，下面的文章将会提到）。</p>
<p>测试微服务架构的应用也是更加复杂的。比如，使用Spring Boot这种框架，开发者启动一个单体应用去写一些测试用例、测试其REST API是很平常事情。相反的是，相类似的测试在微服务中的话，你要启动或者至少去mock其依赖的其他的服务才能完成。再次强调，微服务不是火箭科学，很重要的一点是大家不要低估了这样做的复杂度！</p>
<p>微服务架构模式的另一巨大挑战是实现跨服务的改动。比如，让我们假设你要实现一个需要更改服务A、B、C的功能，而此时A依赖于B，B依赖于C。在传统单体应用中，你可以很简单的去更改对应的模块，集成这些变动然后一起部署它们。然而在微服务架构模式下，你需要小心翼翼的计划和协调每个服务的改动和发布：你需要更新服务C，再更新服务B。然后还要更新服务A。幸运的是，绝大部分时候一个服务的变化仅会影响一个服务，多个服务间需要协调的情况是很少出现的。</p>
<p>部署一个基于微服务架构的应用是更加复杂的。一个传统单体应用可以简单的部署到负载均衡器后面，因为应用都是相同的，拷贝部署就可以了。每个应用配置好数据库和message broker的地址（主机和端口）就好了。相对应的微服务一般是大量的服务组成的，比如，Hailo存在160个不同的服务，Netflix则有多达600多个不同服务，每个服务还有多个运行实例！将会有更多的变化的部分需要去配置、部署、扩展、监控。此外还需要实现一个服务发现机制让其他服务找到它需要通信的服务的地址。传统的基于Ticket和手动运维的方式是不可能处理好这个级别的复杂扩展的。因此，成功部署一个微服务需要开发者对部署方法有更多控制还要对服务执行高水平的自动化。</p>
<p>自动化的其中一种方式是使用现有的Paas平台（比如Cloud Foundry）。PaaS平台为开发者提供了便捷的方式去部署他们的微服务，避免了是他们纠缠于购买和配置IT资源的泥潭。同时，配置PaaS系统和网络的专业人员可以确保遵守了最佳实践和公司策略。另一种自动化方式就是开发自己的PaaS平台。一个典型的开端就是先使用集群方案（比如Kubernetes）配合上Docker容器技术，后续的文章将会介绍基于软件的应用部署方案，比如NGINX是如何在微服务层面方便的处理缓存、访问控制、API计费、监控等问题的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>构建复杂的应用本身就是困难的事情。单体应用架构在针对简单、轻量级的应用的时候是很好的。但是一旦你把那套方案运用在复杂的应用的时候你将会痛苦不堪。尽管微服务架构模式有诸多缺点和实现上的挑战，但对于复杂的、演进的应用来讲是一个更好的选择。</p>
<p>在后续的文章中我将会详细介绍微服务的几个方面，讨论一些诸如服务发现、服务部署选择以及重构单体应用到微服务的的话题。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>第一篇文章翻译完了，说实话胆颤心惊，第一次作大死，厚着脸皮上吧！！！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/04/microservices/Event-Driven Data Management for Microservices/" itemprop="url">
                  微服务之事件驱动的数据管理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-01-04T13:36:23+08:00" content="2017-01-04">
              2017-01-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/microservice/" itemprop="url" rel="index">
                    <span itemprop="name">microservice</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>原文链接:<a href="https://www.nginx.com/blog/event-driven-data-management-microservices/?utm_source=introduction-to-microservices&amp;utm_medium=blog&amp;utm_campaign=Microservices" target="_blank" rel="external"><em>Event-Driven Data Management for Microservices</em></a></strong></p>
<ol>
<li><em><a href="http://www.jianshu.com/p/8d2cfa1fa633" target="_blank" rel="external">微服务介绍</a></em></li>
<li><em><a href="http://www.jianshu.com/p/9e90b2a5df7b" target="_blank" rel="external">构建微服务之使用API网关</a></em></li>
<li><em><a href="http://www.jianshu.com/p/9c03081bc0d9" target="_blank" rel="external">构建微服务之:微服务架构中的进程内通信</a></em></li>
<li><em><a href="http://www.jianshu.com/p/1bf9a46efe7a" target="_blank" rel="external">微服务中的服务发现</a></em></li>
<li><em>微服务之事件驱动的数据管理(本文)</em></li>
<li><em><a href="http://www.jianshu.com/p/31c2a5a8b764" target="_blank" rel="external">选择一种微服务部署策略</a></em></li>
<li><em><a href="http://www.jianshu.com/p/29f4d788e3bb" target="_blank" rel="external">重构单体应用到微服务</a></em></li>
</ol>
<p>这是使用微服务架构构建应用系列的第五篇文章.第一篇文章介绍了微服务架构模式并讨论了使用微服务的优势和劣势 ；第二篇和第三篇文章讨论了微服务架构不同层面的通信问题；第四篇文章密切探讨了服务发现的相关问题；本文章呢，我们换个口味，看看微服务架构模式中的分布式的数据管理问题。</p>
<h2 id="微服务与分布式数据管理问题"><a href="#微服务与分布式数据管理问题" class="headerlink" title="微服务与分布式数据管理问题"></a>微服务与分布式数据管理问题</h2><p>一个单体应用一般只有一个关系型数据库，使用一个关系型数据的优势是应用可以实现ACID，为业务操作进行保证：</p>
<ul>
<li>Atomicity – 操作是原子性的</li>
<li>Consistency – 数据库中的状态永远是一致的</li>
<li>Isolation – 尽管事务是并发的执行，但他们表现的像顺序执行，事务之间不会彼此影响</li>
<li>Durable – 一旦事务提交就不能再撤销</li>
</ul>
<p>因此，应用可以很简单的开始一个事务，操作（增删改）多条数据，然后提交事务。</p>
<p>使用关系型数据库的另一个巨大优势是可以使用SQL，一种丰富的声明式的标准查询语言。 你可以很简单的写一条关联多个数据表的查询语句，关系型数据库管理系统会解析SQL来决定最优执行方案执行该查询。你不必关心诸如数据库如何访问这种低层次的细节问题，另外，你所有的应用数据在一个数据库中，查询起来很容易。</p>
<p>很不幸的是，当转换到微服务架构的时候，数据访问变的越来越复杂。这是因为每个服务拥有的数据是该服务所私有的，要想访问该服务的数据只能通过API。对数据进行封装可以确保微服务之间是松散耦合的，各个服务可以独立于其他服务进行演进。如果多个服务访问同样的数据，那么Schema的更新是很耗时而且需要协调所有服务进行更新。</p>
<p>不同微服务可能使用不同的数据库会让事情变得更糟。现代应用程序存储和处理各种各样的数据，关系数据库并不总是最好的选择。在一些用例下，一种特殊的NoSQL数据库可能有更加方便的数据模型并且提供更好的性能与扩展性 ，比如，对一个存储和查询文档的服务来讲，使用Elasticsearch这样的文档查询引擎可能更加合适；同样的，存储社交图谱的服务更合适使用Neo4J这样的图数据库 。总之，微服务架构的应用经常使用SQL和NoSQL的混合存储，通常叫做多态型数据持久性方案。</p>
<p>一个分区的多态型的数据持久性方案有诸多好处：松耦合、更高的性能、扩展性等，然而这也引入了分布式数据管理的挑战！</p>
<p>第一个挑战就是如何跨多个服务实现业务事务、维护数据的一致性。为什么这是一个问题？让我们看一个在线B2B商店的例子：用户服务维护诸如用户信用额度这样的信息，订单服务管理订单并且确保新订单没有超过用户的信用额度限制。在传统单体应用中，订单服务可以在创建新订单时简单的使用ACID事务去查看用户可用的信用额。</p>
<p>然而在微服务架构中，<strong>ORDER</strong> 和<strong>CUSTOMER</strong>表是各个服务所私有的，如下图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3912920-39d62663419d03a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>订单服务不能直接去访问用户表而只能使用用户服务提供的API。订单服务可能潜在的使用分布式事务，也就是两段提交，然而现在的应用中两段提交通常不是一个可行的选择。CAP理论要求你在可用性和ACID风格的一致性之间进行选择 ，而且。许多流行的技术，比如NoSQL并不支持两段提交，这就尴尬了！维护跨服务和跨数据库的数据一致性是很有必要的，所以我们需要另一种解决方案。</p>
<p>另一项挑战就是如何在多服务中获取数据。比如。假设我们应用需要展示用户信息和他最近的订单，如果订单服务提供API查询用户订单，那么你可以使用 应用程序连接查询数据 ：应用从用户服务查询用户信息，从订单服务查询订单。 假设，订单服务仅支持主键查询订单（也许使用了仅支持主键查询的NoSQL），这种情况下，没有好的方法来检索数据。</p>
<h2 id="事件驱动架构"><a href="#事件驱动架构" class="headerlink" title="事件驱动架构"></a>事件驱动架构</h2><p>对很多应用来讲，方案就是使用事件驱动架构。在该架构中，一个微服务在一些业务发生时发布一个事件，比如更新一条业务记录，其他微服务会订阅该事件，当微服务收到事件后会更新自己的业务记录，导致其他的事件被发布。</p>
<p>你可以使用事件实现跨服务的业务事务。一个事务包含一系列步骤，每个步骤由某微服务更新业务记录并发布事件触发下一步骤组成。下面的图显示如何使用事件驱动方式在创建订单时检查可用信用额度 ，微服务间通过Message Broker交换事件。</p>
<ol>
<li>订单服务创建状态为NEW的订单并发布<strong>Order Created</strong>事件<br><img src="http://upload-images.jianshu.io/upload_images/3912920-c34e0260f81ba3ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></li>
<li>客户服务消费<strong>Order Created</strong>事件，为该订单预订信用并发布<strong>Credit Reserved</strong>事件<br><img src="http://upload-images.jianshu.io/upload_images/3912920-c8a5730c151bf778.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></li>
<li>订单服务消费<strong>Credit Reserved</strong>事件并更改订单状态为<strong>OPEN</strong><br><img src="http://upload-images.jianshu.io/upload_images/3912920-9f629b3f80489e19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></li>
</ol>
<p>更复杂的场景可能调用多个步骤，比如保留订单同时检查用户信用。</p>
<p>假设（a）每个服务原子性的更新数据库并发布事件– 并且–  （b） Message Broker保证事件至少被交付一次，那么你就可以实现跨服务的业务事务了。我们必须注意到一点是，这并不是ACID事务，他们提供更弱一点的最终一致性，这种事务模型可以参考 <a href="http://queue.acm.org/detail.cfm?id=1394128" target="_blank" rel="external">BASE model</a>.</p>
<p>你也可以使用事件来维护提前关联了多个微服务的物化视图。该服务通过订阅相关事件并更新视图，比如，用户订单视图通过订阅订单事件和用户事件来更新用户订单视图。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3912920-24785400e0d9fbd4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>当客户订单视图更新服务接收到来自客户或者订单的事件时，它将更新客户订单视图。你可以使用Mongodb这样的文档数据库为每个用户存储一份文档来实现客户订单更新视图，客户订单视图查询服务可以查询客户订单视图数据库提供客户信息与最近客户订单数据。</p>
<p>事件驱动架构有很多优势也有一些劣势。它使得跨服务事务成为可能，并提供了最终一致性，另一个优势就是它使得应用可以维护物化视图；但是劣势之一是编程模型比ACID事务模型更为复杂 ，通常我们要实现补偿事务来恢复应用级别的错误。比如，一旦信用额度确认失败，你必须要取消订单，并且应用要处理不一致的数据， 这是因为随意的事务是可见的，应用如果读取未更新的物化视图，将会获取到不一致的数据，另外一个劣势是，订阅必须可以检测并忽略重复的事件。</p>
<h2 id="实现原子性"><a href="#实现原子性" class="headerlink" title="实现原子性"></a>实现原子性</h2><p>在事件驱动的架构中，还有一个更新数据与发布事件的原子性问题。比如，订单服务需要插入一条数据到 <strong>ORDER</strong>表并且发布<strong>Order Created</strong>事件，这两个操作原子性完成是很有必要的：假如在数据库更新完成后，事件发布之前服务挂掉了，系统将会存在不一致。标准确保原子性的方式是使用分布式事务调用数据库系统和Message Broker。然而，根据前面我们描述的理由，比如CAP理论，我们是想避免这么干的。</p>
<h2 id="使用本地事务发布事件"><a href="#使用本地事务发布事件" class="headerlink" title="使用本地事务发布事件"></a>使用本地事务发布事件</h2><p>应用发布事件并保证原子性的方法之一是采用多步骤本地事务方法。技巧是有一张EVENT表，表其实就是模拟一个message queue。当然数据库中还存着业务数据的状态，应用开始一个本地数据库事务，更新业务数据记录并往EVENT表中插入一条数据，最后提交事务。一个单独的应用线程或进程轮询EVENT表，并根据查询结果往Message Broker推送事件消息，然后使用本地事务标记事件被发布。下图描述了该设计：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3912920-db0c3e03d9744d32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>订单服务插入数据到ORDER表并且插入Order Created event 到EVENT表。数据发布者线程或进程轮询EVENT表中未发布的事件，发布事件，然后更新EVENT表标记事件已被发布。</p>
<p>这种方案有优势也有劣势。优势之一是保证了在不使用两段提交前提下事件在每次更新后一定被发布 ，当然，应用发布了业务级别的事件，减少了再去推断事件类型的麻烦。劣势之一是这种方案很容易出错，因为要求程序员必须记得更新后去发布事件，该方案另一个局限是使用NoSQL时，由于NoSQL的事务和查询能力局限，实现起来困难。</p>
<p>这种方案使用本地事务来更新数据和发布事件减少了两段提交的使用，现在让我们来看只需更新状态就达到原子性的方法。</p>
<h2 id="挖掘数据库事务日志"><a href="#挖掘数据库事务日志" class="headerlink" title="挖掘数据库事务日志"></a>挖掘数据库事务日志</h2><p>另一种不需要两段提交就实现原子性的方法是挖掘数据库事务日志或提交日志实现事件发布,这就要求变化操作要被记录在数据库事务日志当中，事务日志挖据线程或进程读取事务日志并发布事件到 Message Broker。下图展示了这种方案：<br><img src="http://upload-images.jianshu.io/upload_images/3912920-e1633250c639939c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>例子之一就是开源的<a href="https://github.com/linkedin/databus" target="_blank" rel="external">LinkedIn Databus</a> 项目。 Databus 挖掘 Oracle事务日志并发布相应的事件， LinkedIn使用 Databus 来保持各种派生数据存储与记录系统的一致。</p>
<p>另一个例子就是NoSQL数据库<a href="http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Streams.html" target="_blank" rel="external">streams mechanism in AWS DynamoDB</a>， DynamoDB 流包含在过去 24 小时向 DynamoDB 表中的记录所做的时序性变化 （创建、 更新和删除操作）。应用程序可以从流中读取这些更改并将它们作为事件发布。</p>
<p>事务日志挖掘有优势也有劣势。优势之一是在不使用两段提交的前提下保证了事件一定被发布，事务日志挖据也可以通过拆分应用业务逻辑事件的发布简化整个应用。该方案一个巨大的劣势是：事务日志每个数据库都不同，甚至相同数据库不同版本也会不同（摊手），而且我们很难从低级别事务日志的更新记录中反推高级别的业务事件。</p>
<p>事务日志挖掘通过更新数据库来避免使用两段提交。现在让我们看看一种消除了更新，并完全依靠的事件的方案：</p>
<h2 id="使用事件源"><a href="#使用事件源" class="headerlink" title="使用事件源"></a>使用事件源</h2><p>事件源通过使用截然不同，以事件为中心的方案持久化业务实体，达到了不使用两段提交前提下 的原子性。这种方案存储一系列状态变化的事件而不是存储当前实体的状态。应用可以通过重放事件来重新构建实体的当前状态。一旦业务实体发生变化，一个新的事件就会被添加到事件列表中，由于保存事件是单一操作，本身就是原子性的。</p>
<p>为查看事件源如何工作，我们以订单实体为例子。传统方案下，每个订单会映射到ORDER表并记录数据到ORDER_LINE_ITEM。但当使用事件源编程时，订单服务以存储订单状态变化事件来存储订单：订单创建、批准、运输、取消。每个事件有充足的信息来重新构建订单。<br><img src="http://upload-images.jianshu.io/upload_images/3912920-af829ed8264d124b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>事件存储到专门存储事件的数据库中，数据库提供添加和查询实体事件的API。这个事件数据库也会像我们上面描述的Message Broker一样提供让其他服务订阅事件的API，事件数据库向对其感兴趣的订阅者发布事件，这个事件数据库是事件驱动型微服务的骨架。</p>
<p>事件源的优势：它解决了一个实现事件源架构的关键问题，使得事件发生时可靠的发布事件成为可能，因此，它解决了微服务架构中数据一致性的问题。当然，因为他持久化事件而非领域对象，也避免了面向对象到关系型数据库中的阻抗不匹配问题。事件源也为实体变动提供了100%可靠的审计日志，并使其能够执行可以确定在任何时间点实体状态的时态查询。事件源的另一巨大优势是，业务逻辑与交换事件的实体是松耦合的，这使得迁移一个单体应用到微服务架构更加简单。</p>
<p>事件源也有一些劣势：对程序员来讲这是完全不同的，非常陌生的编程风格，学习曲线陡峭。事件数据库仅仅直接支持主键方式查询业务实体，必须使用 <a href="https://github.com/cer/event-sourcing-examples/wiki" target="_blank" rel="external">Command Query Responsibility Segregation</a> (CQRS) 来实现查询。因此，应用必须来处理最终一致性。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在微服务架构中，每个服务拥有自己的数据存储。不同服务可能是一不同的SQL或者NoSQL数据库。这样的数据库架构有很多优势，当然也带来了分布式数据管理的挑战。挑战之一就是如何实现跨多服务的业务逻辑事务来维持一致性，挑战之二就是如何从多服务查询数据。</p>
<p>对很多应用来讲，使用事件驱动架构来应对这些挑战。实现事件驱动架构的挑战之一是如何保证更新数据状态和发布事件的原子性 ，有几种方案来实现，包括以数据库为message queue，事务日志挖掘，事件源。</p>
<p>剩余的文章将讨论其他方面的问题。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/04/microservices/Choosing a Microservices Deployment Strategy/" itemprop="url">
                  选择一种微服务部署策略
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-01-04T13:36:23+08:00" content="2017-01-04">
              2017-01-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/microservice/" itemprop="url" rel="index">
                    <span itemprop="name">microservice</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/04/microservices/Building Microservices-Using an API Gateway/" itemprop="url">
                  建微服务之使用API网关
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-01-04T13:36:23+08:00" content="2017-01-04">
              2017-01-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/microservice/" itemprop="url" rel="index">
                    <span itemprop="name">microservice</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/04/microservices/Building Microservices-Inter-Process Communication/" itemprop="url">
                  构建微服务之:微服务架构中的进程间通信
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-01-04T13:36:23+08:00" content="2017-01-04">
              2017-01-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/microservice/" itemprop="url" rel="index">
                    <span itemprop="name">microservice</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>原文链接:<a href="https://www.nginx.com/blog/building-microservices-inter-process-communication/?utm_source=introduction-to-microservices&amp;utm_medium=blog&amp;utm_campaign=Microservices" target="_blank" rel="external"><em>Building Microservices: Inter-Process Communication in a Microservices Architecture</em></a></strong></p>
<ol>
<li><em><a href="http://www.jianshu.com/p/8d2cfa1fa633" target="_blank" rel="external">微服务介绍</a></em></li>
<li><em><a href="http://www.jianshu.com/p/9e90b2a5df7b" target="_blank" rel="external">构建微服务之使用API网关</a></em></li>
<li><em>构建微服务之:微服务架构中的进程间通信(本文)</em></li>
<li><em><a href="http://www.jianshu.com/p/1bf9a46efe7a" target="_blank" rel="external">微服务中的服务发现</a></em></li>
<li><em><a href="http://www.jianshu.com/p/9a440c5ea1db" target="_blank" rel="external">微服务之事件驱动的数据管理</a></em></li>
<li><em><a href="http://www.jianshu.com/p/31c2a5a8b764" target="_blank" rel="external">选择一种微服务部署策略</a></em></li>
<li><em><a href="http://www.jianshu.com/p/29f4d788e3bb" target="_blank" rel="external">重构单体应用到微服务</a></em></li>
</ol>
<p>这是使用微服务架构构建应用系列的第三篇文章。第一篇文章介绍了微服务架构模式并讨论了使用微服务的优势和劣势 ；第二篇文章介绍了应用的客户端如何通过API网关作为中介实现服务间的通信；在这篇文章中我们将看一看同一系统间的服务如何通信；第四篇文章主要介绍服务发现的问题。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在传统单体应用中，模块间使用编程语言级别的方法或功能彼此调用。然而微服务架构应用本质上是运行在多台机器上的分布式系统，每个服务都是一个进程！因此，下图为我们展示，微服务必须使用进程间通信（IPC）的机制实现交互：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3912920-f333ee79c1ebd318.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>稍后，我们将看具体的 IPC 技术实现，但首先让我们探讨不同方案设计中的问题。</p>
<h2 id="交互风格"><a href="#交互风格" class="headerlink" title="交互风格"></a>交互风格</h2><p>当我们为服务选择一种IPC机制的时候，我们首先要考虑服务间如何交互，技术上存在多种 client⇔service 交互风格：它们可以按照两大维度分类：第一维度是服务间交互是一对一还是一对多； </p>
<ul>
<li>一对一：每个客户端请求只会被一个服务实例处理。</li>
<li>一对多：每个请求将会被多个服务实例处理</li>
</ul>
<p>第二个维度是交互是同步模式还是异步模式：</p>
<ul>
<li>同步：客户端期望来自服务端的及时响应，甚至可能阻塞并等待。</li>
<li>异步：客户端等待响应时不会阻塞，对异步来讲，及时响应并不是必须的。</li>
</ul>
<p>下列表格展示了两种方式的不同</p>
<p>有下面几种一对一的交互方式：</p>
<ul>
<li>请求/响应模式： 客户端向服务端发送请求并等待响应，并期望服务端可以及时的返回响应。在一个基于线程的应用中，发出请求的线程可能在等待时阻塞线程的执行。</li>
<li>通知（也就是单向请求）：客户端往服务端发送请求，但并不等待响应返回</li>
<li>请求/异步响应：客户端往一个异步返回响应的服务发送请求。客户端等待式并不会阻塞线程，因为设计时就假设请求不会立即返回（js回调）</li>
</ul>
<p>有下面几种一对多的交互方式：</p>
<ul>
<li>发布/订阅模式：客户端发布一个通知消息，消息将会被0或多个感兴趣的服务消费</li>
<li>发布/异步响应：客户端发布一个请求消息，并在一定时间内等待消费消息的服务响应。</li>
</ul>
<p>每个服务通常会使用多种交互风格的组合：对一些服务来讲，简单的IPC机制可能已经足够了，但另外一些服务可能需要几种IPC机制的组合。下图展示了在<strong>taxi-hailing</strong>应用中，当用户请求行程时，服务是如何交互的：<br><img src="http://upload-images.jianshu.io/upload_images/3912920-c46c209a8b21013f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>这个服务使用了通知、请求/响应、发布/订阅风格的组合。比如，乘客使用智能手机向行程管理服务发送一个接送需求的<strong>通知</strong>，行程管理服务将使用<strong>请求/响应</strong>模式调用乘客服务来验证乘客账号是否为活动状态，然后行程管理服务创建行程并使用<strong>发布/订阅</strong>方式来通知诸如分发器（用来定位空闲司机）等服务。</p>
<p>我们已经讨论了交互风格，那么再来看下如何定义API。</p>
<h1 id="定义API"><a href="#定义API" class="headerlink" title="定义API"></a>定义API</h1><p>服务API是服务与客户之间的契约。抛开选择哪种IPC机制的选择，使用一些接口定义语言interface definition language (IDL)准确定义服务API是很重要的！.当然，最好考虑使用API优先的方式来定义服务，通过先写接口定义语言来开始开发，并与客户端开发者（服务消费者）一起review你的设计，先对API定义进行迭代，再去实现这些服务。这样做设计的话将会使你构建更加符合客户需求的服务！</p>
<p>后续文章你将会发现，服务定义和你选择哪种IPC机制息息相关，如果你是要消息机制，API就由消息频道和消息类型组成；如果你使用http，API就是由URLs以及request/response格式组成。稍后我们将会讨论更多关于接口定义语言的细节。</p>
<h2 id="API进化"><a href="#API进化" class="headerlink" title="API进化"></a>API进化</h2><p>服务API将会不可避免的随着时间进化，在传统单体应用中，我们可以很直接的去修改服务并更新所有服务的调用者（refactor）。但是在基于微服务架构的应用中，哪怕服务API的其他消费者都是在一个应用中，去更新所有服务也是相当困难的。你通常不能强制让所有的客户端升级来保持和服务端升级维持步调一致，而且，你还可能会增量部署新服务使得新老服务同时运行，寻找一种处理此种情况的策略是很重要的。</p>
<p>你是如何根据更改的大小来处理服务API的变化的呢？一些变化很小，通常可以与之前版本做到向后兼容，比如，你为请求或相应添加了一个属性；对此，设计服务时考虑服务和客户消费者的鲁棒性原则是很有必要的：使用就版本服务API的客户端可以在新版本服务API下正常工作，服务端为客户端缺失的属性提供默认值，客户端自动忽略额外添加的响应属性。最后强调，注意使用IPC机制和定义消息格式使你的API可以简单方便的进化！</p>
<p>当然，有时候我们不得不对API做一些较大的，不再兼容的变化，而我们这时候又不可能强制每个客户端升级，因此我们的服务就要继续支持运行一段时间的老版本API。如果使用http，我们可以在URL里嵌入服务版本，每个服务实例可能同时处理多个版本的服务，当然，你也可以选择为每个服务版本部署单独的服务实例。</p>
<h2 id="处理局部故障"><a href="#处理局部故障" class="headerlink" title="处理局部故障"></a>处理局部故障</h2><p>就像前面关于API网关文章提到的那样：在分布式系统中总会有无时无刻的局部故障的风险。由于客户端和服务在不同的进程中，服务可能由于挂掉或者维护原因而不能及时响应客户端的请求，或者服务由于过载原因导致响应缓慢。</p>
<p>比如，让我们考虑之前文章提到的<strong>Product details</strong>场景，假设推荐服务没有响应了，一个简单的客户端实现可能无期限的等待服务响应并阻塞，这样不仅导致糟糕的用户体验，在很多应用中还会消耗比如线程这样宝贵的资源，最终就像下图展示的那样，运行时将会用尽所有线程使得服务不再响应任何请求：<br><img src="http://upload-images.jianshu.io/upload_images/3912920-11c7d11329b92789.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>为解决此类问题，设计上处理局部故障是很有必要的。</p>
<p>Netflix给出了一些处理局部故障比较好的方法：</p>
<ul>
<li>网络超时：等待响应时不要一直阻塞，而是使用超时，超时能够保证资源不会一直被占用</li>
<li>限制未完成请求的数量：针对一个请求某服务的客户端，需要设置其未处理请求数量的上限，一旦超过限制就不再处理任何请求，这样就做到快速失败。</li>
<li>断路器模式：跟踪成功和失败请求的数量，如果比率超过了设置的阀值，打开断路器使得后续请求快速失败。如果大量请求失败，就建议服务为不可以状态并决绝处理新请求，过一段时间之后，客户端可以再次重试，一旦成功，关闭断路器。</li>
<li>提供fallback机制：请求失败时提供fallback，比如返回缓存值或者为失败的推荐服务返回默认空集合作为默认值。<br><strong>Netflix Hystrix</strong>是一个实现了这些模式的开源工具包，如果你使用JVM那么一定要考虑使用它！如果你的服务不是运行在JVM中，那也要考虑有等效的实现来处理此类问题。</li>
</ul>
<h2 id="IPC-技术"><a href="#IPC-技术" class="headerlink" title="IPC 技术"></a>IPC 技术</h2><p>我们有不同的IPC技术可供选择：服务可以使用基于请求/响应的同步通信模式，比如基于Http的REST或者Thrift，当然，也可以使用异步基于消息的通信模式，比如AMQP、STOMP。这些通信模式有不同的消息格式，服务可以使用基于文本格式、方便阅读的JSON 或者 XML格式，也可以使用效率更高的二进制格式（比如Avro或Protocol Buffers）。稍后我们将讨论同步IPC机制，现在我们先讨论下异步的IPC机制：</p>
<h3 id="异步，基于消息的通信"><a href="#异步，基于消息的通信" class="headerlink" title="异步，基于消息的通信"></a>异步，基于消息的通信</h3><p>使用消息时，进程间通过异步交换消息来通信。一个客户端通过发送消息的方式请求服务，如果期望服务有响应，也是服务通过向客户端发送另外的消息来实现。由于通信是异步的，客户端不会为了响应等待并阻塞，相反的，客户端编程时就是以服务不会立即返回响应来处理的。</p>
<p>一条消息包含消息头（元数据和发送者）和消息体，消息通过频道进行交换，任意数量的消费者都可以往频道中发消息，任意数量的消费者也可以消费频道中的消息。有<strong>point‑to‑point</strong>和<strong>publish‑subscribe</strong>两种频道：point‑to‑point模式下，频道的消息只会被交付到某一个消费者，这种模式用于前面提到的一对一的交互；publish‑subscribe 模式下，频道的消息将会交付到所有感兴趣的消费者，使用于前面提到的一对多交互风格。</p>
<p>下图展示了<strong>taxi-hailing</strong> 应用可能是一publish-subscribe模式：<br><img src="http://upload-images.jianshu.io/upload_images/3912920-6cb0d76a907b6ec2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>行程管理服务通过向publish-subscribe频道写入trip create消息的方式通知比如分发器这样感兴趣的服务，分发器查找空闲司机并通过向publish-subscribe频道写入Driver Proposed消息通知其他服务。</p>
<p>有多种消息系统供我们选择，当然我们尽量选择一个支持多种编程语言的来使用。一些消息系统支持标准的协议比如 AMQP和STOMP，另一些消息系统有专有但是文档化的协议，大量的开源消息系统可供我们挑选，包括RabbitMQ、Apache Kafka、Apache ActiveMQ和NSQ。统一的来看，他们都支持某种形式的消息和频道，都致力于高可靠，高性能和高扩展性，但是每个消息中介在实现细节上还是有很大的不同：<br>使用消息系统有很多优点：</p>
<ul>
<li>客户端与服务端解耦： 客户端只需要向合适的频道发送消息就实现简单的请求，客户端完全感知不到服务实例的存在，因此不需要再去使用一套服务发现机制去决定服务实例的位置。</li>
<li>缓存消息：在同步的请求/响应协议，比如HTTP下，客户端和服务端在交互的阶段必须保证双方都可用，然而，消息中介会把消息写入队列直到消息被消费者处理位置，这意味着，尽管 在订单履行系统响应缓慢甚至不可用情况下，在线商城仍然可以接受来自客户的订单，只需要先把订单消息简单的入队即可。</li>
<li>灵活的客户-服务端交换风格，消息支持前面提到的所有交互风格。</li>
<li>显示的进程间通信：基于 RPC的通信机制试图使调用远程服务等同于调用本地服务。然而，由于物理定律和局部故障的可能性，事实上他们相当不同。消息使这些差异非常明显，因此开发人员不被虚假的安全感所迷惑。</li>
</ul>
<p>当然消息系统也有缺点：</p>
<ul>
<li>额外的运维复杂度：消息系统毕竟也是额外的系统组件，也要求安装、配置、运维等操作，有必要保证消息系统的高可用，否则会影响整个系统的稳定性。</li>
<li>实现请求/响应交互的复杂度：要实现请求/响应的交互风格还是要做些额外工作的：每条请求消息必要要包含回复频道的标志符以及关联标志符 ，服务回写包含关联ID的消息到回复频道，客户端使用关联ID去匹配请求对应的响应。当然，如果使用直接支持请求/响应的基于IPC机制的方式，将会特别简单。</li>
</ul>
<p>我们已经讨论了基于消息的IPC，再看检验下基于请求/响应的IPC吧：</p>
<h3 id="同步，基于请求-响应的IPC"><a href="#同步，基于请求-响应的IPC" class="headerlink" title="同步，基于请求/响应的IPC"></a>同步，基于请求/响应的IPC</h3><p>当使用同步，基于请求/响应的IPC机制的时候，客户端向服务端发送请求，服务端处理请求并返回响应，很多客户端，发出请求的线程会在等待响应过程中阻塞，另外有一些客户端也会使用异步、事件驱动的代码，比如封装好的Futures 或 Rx Observables。然而，和使用消息不一样，客户端假设请求会立即返回。有几种方案供我们选择，比较流行就是REST和 Thrift，我们先看下REST：</p>
<h4 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h4><p>限制使用REST风格暴露API很流行，REST基本就是使用HTTP的IPC 机制，REST的关键理念是资源，也就是通常代表诸如用户或产品的某个或一组业务对象，REST使用HTTP verbs维护URL指向的资源，比如 GET返回某资源的表示，可能是XML也可能是JSON对象， POST会创建新资源，PUT更新资源··· 引用自Roy Fielding，提出REST的大牛：</p>
<p>“REST provides a set of architectural constraints that, when applied as a whole, emphasizes scalability of component interactions, generality of interfaces, independent deployment of components, and intermediary components to reduce interaction latency, enforce security, and encapsulate legacy systems.”<br>—Fielding, <a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm" target="_blank" rel="external">Architectural Styles and the Design of Network-based Software Architectures</a></p>
<p>下图展示了<strong>taxi-hailing </strong>应用使用REST的场景：<br><img src="http://upload-images.jianshu.io/upload_images/3912920-f0467101397a961a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>乘客向行程服务/trips发送POST请求，行程服务通过向乘客管理服务发送GET请求获取乘客信息，在验证完乘客授权之后，创建行程，行程服务创建行程后返回201响应给手机.</p>
<p>很多用了HTTP暴露服务API的开发就说自己是REST，其实按照 Fielding 在<a href="http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven" target="_blank" rel="external">blog post</a>描述的规定，他们根本不是REST。 Leonard Richardson (no relation)定义了非常有用的 <a href="http://martinfowler.com/articles/richardsonMaturityModel.html" target="_blank" rel="external">maturity model for REST</a>组成了下面几个级别：</p>
<ul>
<li>Level 0 :客户端使用HTTP POST调用服务固定的URL，每次请求指定动作和参数</li>
<li>Level 1：支持资源的概念，请求通过POST，并且要制定要做的动作和参数</li>
<li>Level 2：充分使用 HTTP verbs 执行动作GET获取资源 POST创建资源PUT更新资源，还是要请求参数和请求体，还可以指定请求的参数，使得服务充分使用web基础架构的功能，比如缓存请求等</li>
<li>Level 3:  API定义按照HATEOAS (Hypertext As The Engine Of Application State) 原则。基本的定义就是GET请求返回表示资源的body中包含一些对资源允许动作的链接。比如，客户端可以使用get订单返回的订单body中的一个超链接取消一个订单。HATEOAS 优点之一是：客户端不用在代码中硬编码URL了，另外，由于返回的body中包含允许对资源所作动作的超链接，客户端就不需要再猜测当前资源状态下他可以做哪些操作了。</li>
</ul>
<p>使用基于HTTP的协议的优点有：</p>
<ul>
<li>HTTP 简单而且大家都熟悉</li>
<li>可以用浏览器测试，配合比如Postman插件更佳，命令行curl也很方便（假设使用json或其他数据格式）</li>
<li>直接就支持请求/响应风格的通信</li>
<li>HTTP很友好</li>
<li>无需中介，简化架构</li>
</ul>
<p>使用HTTP的缺点：</p>
<ul>
<li>HTTP只支持请求/响应风格的交互，你可以使用HTTP请求向服务器发送通知，但是服务器一定要返回HTTP响应。</li>
<li>客户端和服务端没有消息buffer机制，交互都是直接的，这就要求交换消息的时候双方必须同时运行。</li>
<li>客户端必须知道每个服务实例的地址，比如URL，正如前面的API网关文章描述的那样，在现代流行的应用架构中，这已经不再是一个问题，我们可以使用服务发现机制来定位服务实例。</li>
</ul>
<p>开发者论坛最近又重新发掘了RESTful API风格接口定义语言的价值，我们可以选择使用<strong>RAML</strong>或者<strong>Swagger</strong>等工具， Swagger允许定义请求响应的消息格式，RAML则要求你使用额外的诸如JSON Schema这样的定义.IDL除了描述API，通常还会提供根据接口定义生产客户端Stub或服务端骨架的工具。</p>
<h2 id="Thrift"><a href="#Thrift" class="headerlink" title="Thrift"></a>Thrift</h2><p><strong>Apache Thrift</strong>是REST的一个很有意思的替代品，它是一个实现跨语言客户端与服务端RPC通信的框架。Thrift提供C语言风格的接口定义语言来定义API，你可以通过编译生成客户端Stub和服务端的骨架，编译器可以为 C++、Java、Python、PHP、Ruby、Erlang、Node.js等不同语言生产代码。</p>
<p>一个Thrift接口包含一个或多个服务，一个服务定义可以类比java的接口：都是一组强类型方法的集合。Thrift方法可以返回值也可以被定义为单向通信，如果方法需要返回值就需要实现请求/响应风格的交互，客户端等待响应的时候可能会抛出异常；单向通信就是我们前面讲到的通知风格的交互，服务端不需要返回响应。</p>
<p>Thrift支持不同的消息格式：JSON、binary以及compact binary。 Binary相对JSON更加高效，因为解码速度更快，compact binary比JSON空间利用率高，见名知意嘛，JSON则对人和浏览器更加的友好 ；Thrift也支持不同的通信协议选择：原生TCP或者HTTP，原生TCP相比HTTP肯定更加高效，但是HTTP对防火墙、人以及浏览器更加的友好。</p>
<h2 id="消息格式"><a href="#消息格式" class="headerlink" title="消息格式"></a>消息格式</h2><p>既然我们已经讨论了HTTP和Thrift，现在再来探讨下消息格式的问题吧：如果你需要消息系统或者REST风格交互，你就必须选择消息格式。其他类似Thrift的IPC机制可能只支持一小部分的消息格式，甚至只会支持一种！在某些情况下，使用一种支持跨语言的消息格式非常重要，哪怕你现在只有一种语言实现微服务，谁又能保证你以后不会使用新的语言呢？</p>
<p>主要有文本和二进制两种格式：文本格式包括JSON和XML等，文本格式不仅仅方便阅读，而且是自描述的，JOSN中对象属性是采用一组键值对的组合来表示的；同样，XML的属性是采用命名元素和值来表示的，这样允许消费者只挑选感兴趣的消息摒弃其他消息，因而这种方式也可以方便的做到向后兼容。</p>
<p>XML文档的结构是由XML schema来指定的，随着时间的流逝，开发者论坛逐步意识到JSON也需要类似的机制：一种选择是使用JSON Schema，要么单独使用，要么作为类似Swagger这种IDL的一部分使用。</p>
<p>文本格式消息的缺点是非常的冗长，尤其是XML格式：由于消息是自描述的，每条消息除了值之外还包含属性的名称，另一个缺点就是解析文本开销略大，这时候可以考虑下二进制格式。</p>
<p>二进制格式也有多种选择：如果使用Thrift，你可以选择Thrift binary，如果选择其他的消息格式，比较流行的还有Protocol Buffers和Apache Avro，两种格式都提供了IDL来定义消息的结构。区别是，Protocol Buffers使用标记字段，而Avro 消费者则需要了解Schema才能解析消息，因此使用Protocol Buffers时，API进化比Avro更容易。这篇 <a href="http://martin.kleppmann.com/2012/12/05/schema-evolution-in-avro-protocol-buffers-thrift.html" target="_blank" rel="external">文章</a>是一个对Thrift、 Protocol Buffers以及 Avro非常好的比较。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>微服务需要使用进程间通信的机制进行交互，当设计你的服务如何通信的时候，需要考虑多个问题：服务如何交互、如何为服务定义API、如何处理API进化、如何处理局部故障。有两种微服务可以使用的IPC机制：异步消息和同步的请求/响应。该系列的下一篇文章，将会讲解微服务架构中的服务发现问题。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/15/learning/distributeSystem/" itemprop="url">
                  学习笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-11-15T17:21:55+08:00" content="2016-11-15">
              2016-11-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/learning/" itemprop="url" rel="index">
                    <span itemprop="name">learning</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>###<br><a href="http://nosqldb.org/p/5458e2aeb7619ae04486b7aa" target="_blank" rel="external">Facebook Haystack Image storage</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/13/JavaScript/You-Dont-Know-JS-Scope&Closures/" itemprop="url">
                  You Don't Know JS - Scope & Closures
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-10-13T15:21:55+08:00" content="2016-10-13">
              2016-10-13
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>最近开始You Don’t Know JS系列书籍，必然先从Scope和Closure这部分搞起,作为一个水水的javascript写手，还是希望多深入下的，啃这本书，精简总结下吧。</p>
</blockquote>
<h2 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h2><blockquote>
<p>几乎所有编程语言的基础功能是将数值存储到变量之中，稍后获取或者修改值。存储值从变量中拿出的功能给予语言存储 <strong>状态state</strong>。我们比较关心的问题是： 这些变量存储在哪里呢？ 最重要的是，程序又是如何在需要的时候找到这些变量的呢？</p>
</blockquote>
<p><code>定义一组规则将变量存储到某处，规定好如何获取这些变量的值，这些规则集合就是我们的主角之一：Scope</code></p>
<h4 id="Scope-1"><a href="#Scope-1" class="headerlink" title="Scope"></a>Scope</h4><ul>
<li>Engine ：负责js的编译和执行</li>
<li>Compiler： Engine的好朋友，负责一些脏活累活，比如语法分析词法分析AST的生成</li>
<li><p>Scope：Engine的另一个好朋友，负责收集和维护一个有关变量（包括方法的）查询列表，并定义一个规范集合去规定在代码执行阶段的变量存取方式</p>
<p>var a = 2<br>很多人估计和我一样是这么理解这句话的：为一个变量分配内存，并标记为a，之后把值2存储到a中。<br>然而事实上在js中并非如此：</p>
<ul>
<li>编译器碰到变量a，Compiler询问<code>特定</code>Scope的集合中是否存在变量a，不存在就创建一个，存在的话Compiler就忽略继续</li>
<li>Compiler将会generate code为Engine运行代码做准备，运行时刻才会执行a=2(assignment)，code engine 在执行的时候会先查看当前scope的集合中是否存在a，如果有就拿出来，没有的话继续查找(nest scope) 找到a再赋值2给它，找到顶 找不到就报错</li>
</ul>
</li>
</ul>
<p><strong>也就是说声明和赋值是两个步骤，而且声明在编译阶段，赋值在执行阶段</strong></p>
<h4 id="赋值表达式"><a href="#赋值表达式" class="headerlink" title="赋值表达式"></a>赋值表达式</h4><ul>
<li>LHS<pre><code>a= 2 ;//Scope中先查找定义 再执行复制
</code></pre></li>
<li>RHS  <pre><code>console.log(a);//Scope中查询值
</code></pre></li>
</ul>
<h4 id="Nested-Scope"><a href="#Nested-Scope" class="headerlink" title="Nested Scope"></a>Nested Scope</h4><p>   类比楼梯中找东西 第一层找不到找第二次，逐层上移，直到顶层找不到，报错</p>
<ul>
<li>ReferenceError  找到楼房顶端了还是找不到</li>
<li>TypeError  找到了，但是还没赋值</li>
</ul>
<h4 id="Lexical-Scope"><a href="#Lexical-Scope" class="headerlink" title="Lexical Scope"></a>Lexical Scope</h4><p><img src="/images/js/scope.png" alt="气泡解释scope "><br>lexical scope 是在方法声明的时候被定义的，也就是说变量所在的scope在写代码的时候就已经确认了,变量的查找规则就像上图所示，但是并不是仅仅只有lexical scope,js也存在其他几种方法对scope进行欺骗 cheating lexical (eval and )</p>
<h5 id="Lexical-Cheating"><a href="#Lexical-Cheating" class="headerlink" title="Lexical Cheating"></a>Lexical Cheating</h5><ul>
<li>eval<pre><code>function foo(str,a){
  eval(str);//cheated, b=3 will shadow b=2
  console.log(a,b);
}
var b = 2;
foo(&quot;var b = 3;&quot;,1);//1,3
</code></pre></li>
<li>eval under strict mode<pre><code>function foo(str){
  &quot;use strict&quot;;
   eval(str);
   console.log(a);//ReferenceError: a is not defined       
}
foo(&quot;var a = 2;&quot;);
</code></pre>eval 在严格模式下只会执行但是不会改变eclosing scope<br><code>尽量在代码中避免eval的使用</code></li>
<li>with<pre><code>function foo(obj){
  with(obj){
    a = 2;
  }
}
var o1 = { a:3 };
var o2 = { b:3 };
foo(o1);
console.log(o1.a);//2
foo(o2);
console.log(o2.a);//undefined
console.log(a);//2, Leaked global
</code></pre>eval会修改当前的scope 而with会创建一个新的lexical scope</li>
<li>性能问题 ： 正常情况下采用lexical scope，js的编译器会帮助我们优化代码，提升sope执行过程中查找变量的速度（scopo在写代码的时候就已经定了），但是一旦代码中加入了eval,编译器就会认为运行过程会改变scope，因此根本不会进行代码的优化，性能下降</li>
</ul>
<h2 id="Closure"><a href="#Closure" class="headerlink" title="Closure"></a>Closure</h2><h4 id="Closure-1"><a href="#Closure-1" class="headerlink" title="Closure"></a>Closure</h4>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/katana.jpg"
               alt="steven xu" />
          <p class="site-author-name" itemprop="name">steven xu</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">25</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">categories</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">steven xu</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  



  




  
  

  

  

  

</body>
</html>
