<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="Steven的博客">
<meta property="og:url" content="http://nonumber1989.github.io/index.html">
<meta property="og:site_name" content="Steven的博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Steven的博客">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="http://nonumber1989.github.io/"/>


  <title> Steven的博客 </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Steven的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/04/microservices/microservices/" itemprop="url">
                  Chris Richardson 微服务系列文章 翻译
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-01-04T13:36:23+08:00" content="2017-01-04">
              2017-01-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/microservice/" itemprop="url" rel="index">
                    <span itemprop="name">microservice</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  2017年的元旦，经过同事介绍开始阅读 nginx blog上的大神<strong>Chris Richardson</strong>发布的七篇针对微服务的文章，刚好决定在新年伊始，做一点技术上的积累，那么就从翻译开始吧！ 这是我第一次翻译外文博客，难免有一些含糊不清的地方，希望各位看官轻喷并帮助我纠正，针对文章中的一些问题 我也将会提出自己的疑问（一开始就是因为有疑问才看的文章，摔！）</p>
<h1 id="原链接地址"><a href="#原链接地址" class="headerlink" title="原链接地址"></a>原链接地址</h1><ol>
<li><a href="https://www.nginx.com/blog/introduction-to-microservices/" target="_blank" rel="external"><em>Introduction to Microservices</em></a></li>
<li><a href="https://www.nginx.com/blog/building-microservices-using-an-api-gateway/?utm_source=introduction-to-microservices&amp;utm_medium=blog&amp;utm_campaign=Microservices" target="_blank" rel="external"><em>Building Microservices: Using an API Gateway</em></a></li>
<li><a href="https://www.nginx.com/blog/building-microservices-inter-process-communication/?utm_source=introduction-to-microservices&amp;utm_medium=blog&amp;utm_campaign=Microservices" target="_blank" rel="external"><em>Building Microservices: Inter-Process Communication in a Microservices Architecture</em></a></li>
<li><a href="https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture/?utm_source=introduction-to-microservices&amp;utm_medium=blog&amp;utm_campaign=Microservices" target="_blank" rel="external"><em>Service Discovery in a Microservices Architecture</em></a></li>
<li><a href="https://www.nginx.com/blog/event-driven-data-management-microservices/?utm_source=introduction-to-microservices&amp;utm_medium=blog&amp;utm_campaign=Microservices" target="_blank" rel="external"><em>Event-Driven Data Management for Microservices</em></a></li>
<li><a href="https://www.nginx.com/blog/deploying-microservices/?utm_source=introduction-to-microservices&amp;utm_medium=blog&amp;utm_campaign=Microservices" target="_blank" rel="external"><em>Choosing a Microservices Deployment Strategy</em></a></li>
<li><a href="https://www.nginx.com/blog/refactoring-a-monolith-into-microservices/?utm_source=introduction-to-microservices&amp;utm_medium=blog&amp;utm_campaign=Microservices" target="_blank" rel="external"><em>Refactoring a Monolith into Microservices</em></a></li>
</ol>
<h1 id="译文链接"><a href="#译文链接" class="headerlink" title="译文链接"></a>译文链接</h1><ol>
<li><em><a href="http://www.jianshu.com/p/8d2cfa1fa633" target="_blank" rel="external">微服务介绍</a></em></li>
<li><em><a href="http://www.jianshu.com/p/9e90b2a5df7b" target="_blank" rel="external">构建微服务之使用API网关</a></em></li>
<li><em><a href="http://www.jianshu.com/p/9c03081bc0d9" target="_blank" rel="external">构建微服务之:微服务架构中的进程间通信</a></em></li>
<li><em><a href="http://www.jianshu.com/p/1bf9a46efe7a" target="_blank" rel="external">微服务中的服务发现</a></em></li>
<li><em><a href="http://www.jianshu.com/p/9a440c5ea1db" target="_blank" rel="external">微服务之事件驱动的数据管理</a></em></li>
<li><em><a href="http://www.jianshu.com/p/31c2a5a8b764" target="_blank" rel="external">选择一种微服务部署策略</a></em></li>
<li><em><a href="http://www.jianshu.com/p/29f4d788e3bb" target="_blank" rel="external">重构单体应用到微服务</a></em></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/04/microservices/Service Discovery in a Microservices Architecture/" itemprop="url">
                  微服务中的服务发现
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-01-04T13:36:23+08:00" content="2017-01-04">
              2017-01-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/microservice/" itemprop="url" rel="index">
                    <span itemprop="name">microservice</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>原文链接:<a href="https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture/?utm_source=introduction-to-microservices&amp;utm_medium=blog&amp;utm_campaign=Microservices" target="_blank" rel="external"><em>Service Discovery in a Microservices Architecture</em></a></strong></p>
<ol>
<li><em><a href="http://www.jianshu.com/p/8d2cfa1fa633" target="_blank" rel="external">微服务介绍</a></em></li>
<li><em><a href="http://www.jianshu.com/p/9e90b2a5df7b" target="_blank" rel="external">构建微服务之使用API网关</a></em></li>
<li><em><a href="http://www.jianshu.com/p/9c03081bc0d9" target="_blank" rel="external">构建微服务之:微服务架构中的进程间通信</a></em></li>
<li><em>微服务中的服务发现(本文)</em></li>
<li><em><a href="http://www.jianshu.com/p/9a440c5ea1db" target="_blank" rel="external">微服务之事件驱动的数据管理</a></em></li>
<li><em><a href="http://www.jianshu.com/p/31c2a5a8b764" target="_blank" rel="external">选择一种微服务部署策略</a></em></li>
<li><em><a href="http://www.jianshu.com/p/29f4d788e3bb" target="_blank" rel="external">重构单体应用到微服务</a></em></li>
</ol>
<p>这是使用微服务构建应用的第四篇文章。第一篇文章介绍了微服务架构模式并讨论了使用微服务的优势和劣势，该系列的第二和第三篇文章 描述了微服务架构中通信的不同方面，本篇文章我们将密切讨论下服务发现的问题。</p>
<h1 id="为什么使用服务发现"><a href="#为什么使用服务发现" class="headerlink" title="为什么使用服务发现"></a>为什么使用服务发现</h1><p>设想下，我们写了一些通过REST API或者Thrift API调用某个服务的代码，为了发起这个请求，你的代码需要知道服务实例的网络地址(IP 地址和端口号）。在传统运行在物理机器上的应用中，某个服务实例的网络地址一般是静态的，比如，代码可以从只会偶尔更新的配置文件中读取网络地址。<br>然而在现在流行的基于云平台的微服务应用中， 有更多如下图所示的困难问题需要去解决：<br><img src="http://upload-images.jianshu.io/upload_images/3912920-4742d0f9ff9bdeb9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>服务实例需要动态分配网络地址，而且，一组服务实例可能会因为自动扩展、失败或者升级发生动态变化，因此 你的客户端代码应该使用更加精细的服务发现机制。<br>有两种主要的服务发现机制：<a href="http://microservices.io/patterns/client-side-discovery.html" target="_blank" rel="external">客户端发现</a> 和 <a href="http://microservices.io/patterns/server-side-discovery.html" target="_blank" rel="external">服务端发现</a>。让我们先看客户端发现机制。</p>
<h2 id="客户端发现模式"><a href="#客户端发现模式" class="headerlink" title="客户端发现模式"></a>客户端发现模式</h2><p>当我们使用 <a href="http://microservices.io/patterns/client-side-discovery.html" target="_blank" rel="external">客户端发现</a>的时候，客户端负责决定可用服务实例的网络地址并且在集群中对请求负载均衡, 客户端访问<strong>服务登记表</strong>，也就是一个可用服务的数据库，然后客户端使用一种负载均衡算法选择一个可用的服务实例然后发起请求。<br>下图展示了该结构模式：<br><img src="http://upload-images.jianshu.io/upload_images/3912920-76cc7f3f5107c3af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>服务实例的网络地址在服务启动的时候被登记到服务注册表中 ，当实例终止服务时从服务注册表中移除。服务实例的注册一般是通过心跳机制阶段性的进行刷新。</p>
<p><a href="https://netflix.github.io/" target="_blank" rel="external">Netflix OSS</a> 为客户端发现机制提供了很多优秀的例子。<a href="https://github.com/Netflix/eureka" target="_blank" rel="external">Netflix Eureka</a> 实现了服务注册表，它通过提供REST API来管理服务实例注册以及可用实例的查询。<a href="https://github.com/Netflix/ribbon" target="_blank" rel="external">Netflix Ribbon</a> 是一个与Eureka一起使用并在多个可用实例间对请求负载均衡的IPC客户端。我们将在下面文章深入讨论Eureka。</p>
<p>客户端发现机制有诸多优势和劣势：该模式除了服务注册表之外没有其他的活动部分了，相对来说还是简单直接的，而且，由于客户端知道相关的可用服务实例，那么就可以使用更加智能的，特定于应用的负载均衡机制，比如一致性哈希。一个明显的缺点是它把客户端与服务注册表紧耦合了，你必须为每一种消费服务的客户端对应的编程语言和框架实现服务发现逻辑。</p>
<p>现在看完了客户端发现，再让我们看下服务端发现吧。</p>
<h2 id="服务端发现模式"><a href="#服务端发现模式" class="headerlink" title="服务端发现模式"></a>服务端发现模式</h2><p>服务发现的另一种模式就是<a href="http://microservices.io/patterns/server-side-discovery.html" target="_blank" rel="external">服务端发现模式</a>。下图展示了该模式的结构：<br><img src="http://upload-images.jianshu.io/upload_images/3912920-76dce8ab07216514.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>客户端通过一个负载均衡器向服务发送请求，负载均衡器查询服务注册表并把请求路由到一台可用的服务实例上。和客户端发现一样，服务实例通过服务注册表进行服务的注册和注销。</p>
<p> <a href="https://aws.amazon.com/elasticloadbalancing/" target="_blank" rel="external">AWS Elastic Load Balancer</a> (ELB) 是服务端发现路由的一个示例。一个ELB通常对来自外部互联网的请求进行负载均衡，当然，你也可以使用ELB对虚拟私有云(VPC)的内部请求进行负载均衡。客户端通过DNS域名向ELB发起HTTP或者TCP请求，ELB将请求负载均衡到一系列注册的Elastic Compute Cloud (EC2) 实例 或者EC2 Container Service (ECS) 的容器中，两者并没有分割的服务注册表，EC2 实例和ECS容器都是通过ELB进行注册的。</p>
<p>类似NGINX PLUG和NGINX这些HTTP服务器和负载均衡器可以作为服务端发现负载均衡来使用。比如 <a href="https://www.airpair.com/scalable-architecture-with-docker-consul-and-nginx" target="_blank" rel="external">这篇博客</a> 就描述了使用<a href="https://github.com/hashicorp/consul-template" target="_blank" rel="external">Consul Template</a> 动态重配置NGINX反向代理，Consul Template是一种根据存储在Consul 服务注册表的配置数据阶段性重新生成任意配置文件的工具 ，每当文件发生变化时，它将运行任意的Shell 命令。在博客描述的例子中，Consul Template 生成用于配置反向代理的<strong>nginx.conf</strong>文件，然后运行一个命令行告知NGINX重载配置。更复杂的实现可能使用 <a href="https://www.nginx.com/products/on-the-fly-reconfiguration/?utm_source=service-discovery-in-a-microservices-architecture&amp;utm_medium=blog&amp;utm_campaign=Microservices" target="_blank" rel="external">HTTP API or DNS</a>动态重配置NGINX Plus。</p>
<p>一些部署环境使用诸如<a href="https://github.com/kubernetes/kubernetes/blob/master/docs/design/architecture.md" target="_blank" rel="external">Kubernetes</a> 和<a href="https://mesosphere.github.io/marathon/docs/service-discovery-load-balancing.html" target="_blank" rel="external">Marathon</a>在集群中的每个主机上运行一个代理，这些代理扮演了服务端发现负载均衡的角色，代理可以根据主机IP地址和服务分配的端口号来路由客户端请求，代理因此可以透明的把客户端请求转发到集群中某台可用的服务实例上去。</p>
<p>服务端发现模式有一些优势也有一些劣势：一个巨大的优势是，服务发现的细节对客户端来说是抽象的，客户端仅需向负载均衡器发送请求即可。这种方式减少了为消费服务的不同编程语言与框架实现服务发现逻辑的麻烦。当然，正如前面所述，一些部署环境已经提供了该功能。这种模式也有一些劣势： 除非部署环境已经提供了负载均衡器，否则这又是一个需要额外设置和管理的可高可用的系统组件。</p>
<h1 id="服务注册表"><a href="#服务注册表" class="headerlink" title="服务注册表"></a>服务注册表</h1><p><a href="http://microservices.io/patterns/service-registry.html" target="_blank" rel="external">服务注册表</a> 是服务发现的关键部分，它是一个包含服务实例网络地址的的数据库。一个服务注册表需要高可用和实时更新，客户端可以缓存从服务注册表获取的网络地址。然而，这样的话缓存的信息最终会过期，客户端不能再根据该信息发现服务实例。因此，服务注册表对集群中的服务实例使用复制协议来维护一致性。</p>
<p>之前也提到 <a href="https://github.com/Netflix/eureka" target="_blank" rel="external">Netflix Eureka</a> 是服务注册表的好例子，它为服务实例的注册与查询提供了REST API：一个服务实例可以使用POST来注册自己的网络地址，它必须每30秒通过PUT去刷新，服务实例可以直接或者在服务实例注册超时的时候使用DELETE删除注册表中的信息，正如你所料，客户端可以使用HTTP GET获取注册实例的信息。</p>
<p>Netflix通过在每一个Amazon EC2 availability zone运行一到多个Eureka服务<a href="https://github.com/Netflix/eureka/wiki/Configuring-Eureka-in-AWS-Cloud" target="_blank" rel="external"> 实现高可用</a>  。每一个Eureka服务器运行在一个关联 <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html" target="_blank" rel="external">Elastic IP地址</a>的 EC2 实例上。<strong>DNS TEXT</strong>记录了Eureka集群的配置文件，配置文件映射availability zones到一组Eureka服务器可用的网络地址。 Eureka 服务器启动的时候将会查询DNS获取Eureka集群的配置、查询同等节点并为自己分配一个未被使用的Elastic IP地址。</p>
<p>Eureka clients – services和service clients，通过查询DNS发现Eureka服务器的网络地址。客户端更倾向使用在同一availability zone中的Eureka服务器，当然，如果该zone中没有可用的网络地址，它将使用另一zone中的。</p>
<p>其他的服务注册表例子包括：</p>
<ul>
<li><a href="https://github.com/coreos/etcd" target="_blank" rel="external">etcd</a> ，一个高可用、分布式、一致性、key-value 方式的存储，被用在分享配置和服务发现中。两个著名的项目使用了它：Kubernetes 和 <a href="http://pivotal.io/platform" target="_blank" rel="external">Cloud Foundry</a>.</li>
<li><a href="https://www.consul.io/" target="_blank" rel="external">consul</a> ，一个发现和配置服务的工具，为客户端注册和发现服务提供了API，Consul还可以通过执行健康检查决定服务的可用性。</li>
<li><a href="http://zookeeper.apache.org/" target="_blank" rel="external">Apache Zookeeper</a> ，是一个广泛使用、高性能的针对分布式应用的协调服务。 Apache Zookeeper本来是Hadoop的子工程，现在已经是顶级工程了。</li>
</ul>
<p>正如前面所述，一些诸如Kubernetes、Marathon和AWS之类的应用并没有显示的服务注册表，相反，服务注册表是架构内置的一部分。</p>
<p>我们已经看过了服务注册表的概念，现在我们看下服务实例是如何使用注册表注册的：</p>
<h2 id="服务注册选项"><a href="#服务注册选项" class="headerlink" title="服务注册选项"></a>服务注册选项</h2><p>正如前面提到的那样，服务实例必须使用服务注册表来进行服务的注册和注销，我们有几种方式来处理服务的注册和注销，其中之一是服务实例自己注册自己也就是<a href="http://microservices.io/patterns/self-registration.html" target="_blank" rel="external">self-registration 模式</a>，另一种是系统的其他组件管理服务实例的注册，也就是 <a href="http://microservices.io/patterns/3rd-party-registration.html" target="_blank" rel="external">third-party registration 模式</a>.。我们先看下self-registration模式：</p>
<h3 id="Self-Registration模式"><a href="#Self-Registration模式" class="headerlink" title="Self-Registration模式"></a>Self-Registration模式</h3><p>当使用<a href="http://microservices.io/patterns/self-registration.html" target="_blank" rel="external">self-registration 模式</a>,时，服务实例自己负责通过服务注册表对自己进行注册和注销，另外如果有必要的话，服务实例可以通过发送心跳请求防止注册过期，下图展示了该模式的结构：<br><img src="http://upload-images.jianshu.io/upload_images/3912920-5bd07f6c772a719f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p><a href="https://github.com/Netflix/eureka" target="_blank" rel="external">Netflix OSS Eureka client</a>就是这种模式的一个例子，Eureka客户端处理服务实例注册和注销的各个方面。<a href="http://projects.spring.io/spring-cloud/" target="_blank" rel="external">Spring Cloud project</a>实现了包括服务发现在内的不同模式，使得自动注册服务实例到Eureka变的简单。你可以简单的在你的java配置类上添加@EnableEurekaClient注解即可。</p>
<p>self-registration模式有一些优势也有一些劣势：优势之一是它相对简单，而且不强制使用其他的系统组件。然而，一个很大的劣势是 它使得服务实例和服务注册表强耦合 ，你必须在每一个使用服务的客户端编程语言和架构代码中实现注册逻辑。</p>
<p>解绑服务和服务注册表的另一替换方案是，使用third-party registration 模式。</p>
<h3 id="Third-Party-Registration模式"><a href="#Third-Party-Registration模式" class="headerlink" title="Third-Party Registration模式"></a>Third-Party Registration模式</h3><p>当使用<a href="http://microservices.io/patterns/3rd-party-registration.html" target="_blank" rel="external">third-party registration 模式</a>的时候，服务实例本身并不负责通过服务注册表注册自己，相反的，通过另一个被称作 <em>service registrar</em>系统组件来处理注册。 service registrar通过轮询或者订阅事件来检测一些运行实例的变化，当它检测到一个新的可用服务实例时就把该实例注册到服务注册表中去，service registrar还负责注销已经被终止的服务实例，下图展示了该模式的架构：<br><img src="http://upload-images.jianshu.io/upload_images/3912920-e68df99cf47bfeec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>service registrar其中一个例子是开源的<a href="https://github.com/gliderlabs/registrator" target="_blank" rel="external">Registrator</a> 项目，它自动的对部署到Docker 容器中的服务实例进行注册和注销。 Registrator支持不同的服务注册表，包括etcd和Consul。</p>
<p>service registrar的另一个例子是 <a href="https://github.com/netflix/Prana" target="_blank" rel="external">NetflixOSS Prana</a>，原本是为非JVM语言的服务所设计，它像服务实例的跨斗一样和服务实例一起运行，Prana使用Netflix Eureka对服务进行注册和注销。</p>
<p>service registrar是部署环境的内置组件，EC2实例可以自动扩展组 并可使用ELB进行服务注册。Kubernetes 服务是自动注册的并能使其可以被发现。</p>
<p>third-party registration模式有一些优势也有一些劣势：主要优势是使得服务从服务注册表中被解耦，你不必为开发者使用的每种开发语言和框架实现服务注册的逻辑，相反，服务实例的注册被一个专有服务以集中式的方式处理。</p>
<p>该模式的劣势是，除非它被内置在部署环境中，不然这又是一个需要被设置和管理的高可用系统组件。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在一个微服务应用中，一组运行的服务实例是动态变化的，实例有动态分配的网络地址，因此，为了使得客户端能够向服务发起请求，必须要要有服务发现机制。</p>
<p>服务发现的关键是<a href="http://microservices.io/patterns/service-registry.html" target="_blank" rel="external">服务注册表</a>，服务注册表是可用服务实例的数据库，它提供了管理和查询使用的API。服务实例使用这些管理API进行服务的注册和注销，系统组件使用查询API来发现可用的服务实例。</p>
<p>有两种服务发现的模式：客户端发现和服务端发现。在使用<a href="http://microservices.io/patterns/client-side-discovery.html" target="_blank" rel="external">客户端发现模式</a>的系统中，客户端直接查询服务注册表，选择一个可用的实例并发起请求，在一个使用<a href="http://microservices.io/patterns/server-side-discovery.html" target="_blank" rel="external">服务端发现模式</a>的系统中，客户端通过路由发起请求，路由会查询服务注册表并把请求转发到可用的服务实例上。</p>
<p>对服务实例来讲有两种方式可以对服务注册表进行注册和注销，一种是服务实例本身通过服务注册表来注册自己，也就是<a href="http://microservices.io/patterns/self-registration.html" target="_blank" rel="external">self-registration模式</a>，另一种则是第三方系统组件代表实例来处理服务的注册和注销，也就是<a href="http://microservices.io/patterns/3rd-party-registration.html" target="_blank" rel="external">third-party registration模式</a>。</p>
<p>在一些部署环境中，你需要使用诸如<a href="https://github.com/Netflix/eureka" target="_blank" rel="external">Netflix Eureka</a>、<a href="https://github.com/coreos/etcd" target="_blank" rel="external">etcd</a>, 或者<a href="http://zookeeper.apache.org/" target="_blank" rel="external">Apache Zookeeper</a>这样的服务注册表来设置你自己的服务发现架构。在另一些部署环境中，服务发现则是内置组件，比如<a href="https://github.com/kubernetes/kubernetes/blob/master/docs/design/architecture.md" target="_blank" rel="external">Kubernetes</a> 和 <a href="https://mesosphere.github.io/marathon/docs/service-discovery-load-balancing.html" target="_blank" rel="external">Marathon</a>用来处理服务注册和注销，他们同样也在集群的每一个主机上运行一个代理来扮演<a href="http://microservices.io/patterns/server-side-discovery.html" target="_blank" rel="external">服务端发现</a>路由的角色。</p>
<p>一些诸如NGINX的HTTP反向代理和负载均衡器 可以用作服务端发现负载均衡器使用，服务注册表可以向NGINX推送路由信息并调用优雅的配置更新，比如，你可以使用<a href="https://hashicorp.com/blog/introducing-consul-template.html" target="_blank" rel="external">Consul Template</a>。 NGINX Plus 支持<a href="https://www.nginx.com/products/on-the-fly-reconfiguration/?utm_source=service-discovery-in-a-microservices-architecture&amp;utm_medium=blog&amp;utm_campaign=Microservices" target="_blank" rel="external">额外的动态重配置机制</a> ：它可以使用DNS从服务注册表 拉取服务实例的信息，并且为远程重配置提供API。</p>
<p>在该系列之后的文章中我们将继续挖掘微服务的各个方面。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/04/microservices/Refactoring a Monolith into Microservices/" itemprop="url">
                  重构单体应用到微服务
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-01-04T13:36:23+08:00" content="2017-01-04">
              2017-01-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/microservice/" itemprop="url" rel="index">
                    <span itemprop="name">microservice</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这是使用微服务架构构建应用系列的第七篇也是最后一篇文章，第一篇文章介绍了微服务架构模式，并讨论了使用微服务架构的优势和劣势，接下来的文章讨论微服务架构的不同方面：使用API网关、进程间通信、服务发现、事件驱动的数据管理以及部署微服务，本篇文章，让我们看下如何把一个单体应用重构为微服务架构的应用。</p>
<p>我希望这个系列的文章使你对微服务架构有一些好的理解，比如它的优势和劣势，何时使用微服务等 ，或许微服务架构对您的组织将非常合适。</p>
<p>然而，你现在更可能正在为一个庞大的、复杂的单体应用而工作，你每天正经历着开发和部署单体应用的缓慢和痛苦 ，微服务看起来更像一个遥远的极乐世界。幸运的是，我们有几个策略可以使你逃离单体的地狱。本篇文章我将描述如何渐进的把单体应用重构为一系列的微服务。</p>
<h1 id="重构为微服务架构的概览"><a href="#重构为微服务架构的概览" class="headerlink" title="重构为微服务架构的概览"></a>重构为微服务架构的概览</h1><p>把一个单体应用转化为微服务实际是<a href="https://en.wikipedia.org/wiki/Software_modernization" target="_blank" rel="external">应用现代化</a>的一种形式，这个事情开发者已经做了十多年了，因此，有一些经验在我们重构应用为微服务时候可以重用。</p>
<p>策略之一是不要使用“Big Bang”式的重写，也就是不要集中所有的力量从头构建一个新的基于微服务的应用，尽管那个方式听起来很诱人，实际会有极大的风险，最终也会以失败告终。正如 Martin Fowler <a href="http://www.randyshoup.com/evolutionary-architecture" target="_blank" rel="external">所说</a>：“the only thing a Big Bang rewrite guarantees is a Big Bang!”。</p>
<p>避免使用Big Bang重写，我们应该渐进式的重构我们的单体应用，我们逐步的构建由微服务组成的新应用，并与我们的单体应用一起运行。随着时间的推移，单体应用实现的功能将会缩水，直到完全消失或者变成另外一个微服务。这种策略可以类比于在高速路上只把车开到70迈-有挑战性但是比Big Bang重写危险小。</p>
<p>Martin Fowler 提到了这种应用现代化的策略，称其为<a href="http://www.martinfowler.com/bliki/StranglerApplication.html" target="_blank" rel="external">Strangler Application</a>，名称来源于热带雨林中的扼杀藤蔓，扼杀藤蔓生长在大树的周围企图得到树冠处的阳光，最后树木会死掉，只留下一堆树状的藤蔓。应用现代化 遵循这样的模式，我们将会围绕的遗留应用构建由一系列微服务组成的新的应用，最终遗留应用将会消失。<br><img src="http://upload-images.jianshu.io/upload_images/3912920-ed317d25d4200ca5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>让我们来看实现该目标可采用的不同策略：</p>
<h1 id="策略一：停止挖掘"><a href="#策略一：停止挖掘" class="headerlink" title="策略一：停止挖掘"></a>策略一：停止挖掘</h1><p> <a href="https://en.wikipedia.org/wiki/Law_of_holes" target="_blank" rel="external">Law of Holes</a> 告诉我们一旦你落入洞穴，你应该停止继续挖洞！一旦你的单体应用变的难以管理，这是一个需要听取的极好的建议。换句话讲，你应该停止让单体应用继续变的更加庞大，这意味着，当你需要实现新功能的时候，你不应该往单体应用中添加新的代码。相反的，这个策略的重要一点是，把新代码放到一个独立的微服务中去。下图展示了应用该方法后的系统架构：<br><img src="http://upload-images.jianshu.io/upload_images/3912920-7bb605084710b1ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>除了新服务和遗留的单体应用，还多出来其他的两个组件：第一个组件是请求路由器，用来处理HTTP请求，这和我们前面所说的API网关类似，路由器发送请求到对应新功能的新服务上去，路由遗留应用的请求到单体应用中去。</p>
<p>另一个组件就是胶水代码，用来集成服务和单体应用。一个服务很少独立存在，一般都需要访问单体应用拥有的数据。胶水代码存在于服务端，或者单体端，或者两端均有，用来负责数据的集成，服务使用胶水代码对单体拥有的数据进行读写操作。</p>
<p>服务有三种策略可以用来访问单体的数据:</p>
<ul>
<li>调用单体提供的远程API</li>
<li>直接访问单体拥有的数据库</li>
<li>维护自己的数据副本，副本需要从单体应用端同步过来</li>
</ul>
<p>胶水代码有时也被称为<em>anti-corruption layer</em>，这是因为胶水代码防止了拥有自己纯净领域模型的服务被来自遗留单体应用的领域模型的设计理念所污染。胶水代码在两种不同的模型间进行转换。anti-corruption layer一词首次出现在Eric Evans 所著的必读之书 <a href="https://domainlanguage.com/ddd/" target="_blank" rel="external">Domain Driven Design</a> 中，并在<a href="http://domainlanguage.com/ddd-resources/ddd-surrounded-by-legacy-software/" target="_blank" rel="external">white paper</a>中被提炼修正。开发一个anti-corruption layer不是一项简单的事情，但如果不想陷入单一地狱，还是有必要搞一个的。</p>
<p>把新功能实现为轻量级的服务有诸多优势：它避免单体应用最终变的不可管理，服务同时可以被独立于单体去开发、部署和扩展。你可以通过创建每一个新的服务体会到微服务架构的优势。</p>
<p>然而，这种方式并没有解决单体中的问题，为了解决这些问题，你需要拆分单体。让我们看一下拆分的策略：</p>
<h1 id="策略二：前后端分离"><a href="#策略二：前后端分离" class="headerlink" title="策略二：前后端分离"></a>策略二：前后端分离</h1><p>缩小单体应用的策略之一是把展示层从业务逻辑层和数据访问层中拆分出来。一个典型的企业应用一般包含至少三种不同的组件：</p>
<ul>
<li>展示层：用来处理HTTP请求并实现基于REST API或者基于HTML的Web UI，在一个用户界面复杂的应用中，展示层通常包含大量的代码</li>
<li>业务逻辑层：应用的核心并实现业务规则的组件</li>
<li>数据访问层：访问诸如数据库和消息中介等基础架构的组件。</li>
</ul>
<p>通常展示逻辑对于后台业务逻辑与数据访问逻辑来讲，彼此有清晰的划分。业务层有由一个或多个门面组成的粗粒度API，它封装了业务逻辑组件，这些API是拆分单体应用到两个更小应用时候的自然缝隙。一个应用包含展示层，另一应用包含业务逻辑和数据访问逻辑，经过拆分，展示逻辑的应用向业务逻辑应用发起远程调用，下图展示了重构前后的架构：<br><img src="http://upload-images.jianshu.io/upload_images/3912920-48f9d932a6016ea1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>这种方式拆分单体应用有两个大的优势：它使得两个应用可以独立的开发、部署和扩展，尤其是它允许展示层开发者快速迭代用户界面并容易的进行A|B测试，这种方式的另一优势是它暴露了可以被其他微服务调用的远程API。</p>
<p>这种策略，也仅仅是部分解决方案，这样重构完之后，很可能两个应用逐步变成两个不可管理的单体。你需要使用第三者策略消除剩余的单体部分。</p>
<h1 id="策略三：提取服务"><a href="#策略三：提取服务" class="headerlink" title="策略三：提取服务"></a>策略三：提取服务</h1><p>重构第三个策略是把单体中存在的模块变成独立的微服务。每一次你提取模块并把其转化为服务，单体就会缩小，一旦你覆盖了足够多的模块，单体就将不再是一个问题，单体要么消失掉要么小到变成另外一个微服务。</p>
<h2 id="确定需要转化为服务的模块的优先级"><a href="#确定需要转化为服务的模块的优先级" class="headerlink" title="确定需要转化为服务的模块的优先级"></a>确定需要转化为服务的模块的优先级</h2><p>一个庞大、复杂的单体应用有数十甚至上百个模块组成，所有的模块都是需要提取的候选。确定哪一个模块需要首先被提取是很有挑战性的问题，一个好的方式是先选择容易提取的模块作为开始，这将给你一些微服务总体上概览以及尤其是提取过程上的经验。在这之后，你可以提取那些可以给你带来最大优势的模块。</p>
<p>把一个模块转化为一个服务通常是需要一定时间的。你想要根据你可以获得优势的大小排列你的模块，通常转换经常变化的模块带来的优势最大。一旦你把一个模块转化为服务，你就可以独立于单体来开发、部署它 了，这会极大的加速你的开发效率。</p>
<p>提取那些对资源有独特需求的模块也会带来很多优势，比如，把拥有内存数据的模块转化为服务，就可以把服务部署到拥有大量内存的主机上，同样的，提取一个需要实现计算密集型算法的模块也是很值得的，因为该服务可以被部署到有多颗CUP的主机上，通过把有独特资源需求的模块转化为服务，可以使得应用更容易扩展。</p>
<p>当决定哪个模块需要提取时，查看已存在的粗粒度的边界（也就是缝隙）是很有用的，这会使模块转化到服务更加简单和低廉。边界的例子之一是，一个模块只通过异步消息与应用的其他部分进行通信，把该模块转化成微服务是相当廉价和简单的。</p>
<h2 id="如何提取模块"><a href="#如何提取模块" class="headerlink" title="如何提取模块"></a>如何提取模块</h2><p>提取模块的第一步是确定模块与单体应用间的粗粒度接口，由于单体和模块需要访问彼此拥有的数据，一般是一些双向的API。由于依赖的错综复杂以及模块与应用其他部分间细粒度的交互，实现这些API一般非常有挑战性。重构使用<a href="http://martinfowler.com/eaaCatalog/domainModel.html" target="_blank" rel="external">领域对象模式</a> 设计的业务逻辑尤其困难，因为领域模型类中彼此包含大量的关联关系 。你一般需要进行大的代码改动才能打破这些依赖，下图展示了重构过程：</p>
<p>一旦你实现了粗粒度的接口，你就可以把这些模块转化为独立的服务。为了实现这个目标，你必须写代码使得单体应用和服务可以通过进程间通信机制的API进行交互。下图展示了应用重构前、中、后的架构：<br><img src="http://upload-images.jianshu.io/upload_images/3912920-a0b9bce56c11edef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>在这个例子中，模块Z是要被提取的候选模块，它的组件被模块X使用，它本身使用到模块Y。重构第一步是定义一组粗粒度的API，第一个接口是模块X调用模块Z的入端接口，第二个接口是模块Z调用模块Y的出端接口。</p>
<p>重构的第二步是把模块转化为独立的服务，出端和入端的接口使用IPC机制的代码实现，你最有可能需要通过模块 Z 结合 <a href="http://microservices.io/patterns/microservice-chassis.html" target="_blank" rel="external">Microservice Chassis framework</a>来处理诸如服务发现这样的横切关注点。</p>
<p>一旦你提取了某个模块，你就拥有了另一个可以独立于单体应用和其他服务来开发、部署、扩展的新服务，你甚至可以从头重写这个服务； 在这种状况下，API代码集成单体和微服务，变成了用以转换两种领域模型的anti-corruption层。每次你提取一个模块，你就又向微服务的方向迈出一步，随着时间的推移，单体应用将会缩水，你也会拥有更多的微服务。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>从一个现存应用迁移到微服务的过程是应用现代化的一种形式，你不应该以从头完全重写的方式把现存应用变为微服务，相反的，你应该逐步的把应用重构为一系列的微服务。你可以使用三种策略：使用微服务实现新的功能；把表现层从业务逻辑和数据访问组件中拆分出来；把单体应用中的现有模块转化为服务。随着时间推移，微服务的数量将会增长，你团队的敏捷性和开发速度也会提升。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/04/microservices/Introduction to Microservices/" itemprop="url">
                  微服务介绍
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-01-04T13:36:23+08:00" content="2017-01-04">
              2017-01-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/microservice/" itemprop="url" rel="index">
                    <span itemprop="name">microservice</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>原文链接:<a href="https://www.nginx.com/blog/introduction-to-microservices/" target="_blank" rel="external"><em>Introduction to Microservices</em></a></strong></p>
<ol>
<li><em>微服务介绍(本文)</em></li>
<li><em><a href="http://www.jianshu.com/p/9e90b2a5df7b" target="_blank" rel="external">构建微服务之使用API网关</a></em></li>
<li><em><a href="http://www.jianshu.com/p/9c03081bc0d9" target="_blank" rel="external">构建微服务之:微服务架构中的进程内通信</a></em></li>
<li><em><a href="http://www.jianshu.com/p/1bf9a46efe7a" target="_blank" rel="external">微服务中的服务发现</a></em></li>
<li><em><a href="http://www.jianshu.com/p/9a440c5ea1db" target="_blank" rel="external">微服务之事件驱动的数据管理</a></em></li>
<li><em><a href="http://www.jianshu.com/p/31c2a5a8b764" target="_blank" rel="external">选择一种微服务部署策略</a></em></li>
<li><em><a href="http://www.jianshu.com/p/29f4d788e3bb" target="_blank" rel="external">重构单体应用到微服务</a></em></li>
</ol>
<p>微服务现在受到了大量的关注︰ 文章、 博客、 社交媒体和学术会议上的讨论都能看到该词汇的身影。微服务正迅速走向 Gartner Hype cycle 所指的快速发展期。同时，软件社区的一些怀疑论者指出微服务并不是什么新鲜玩意儿。这些唱反调的人说微服务和SOA概念并没有什么不同，旧瓶装新酒而已，顺势炒炒新概念。然而，不管说是夸大也好，怀疑也好，微服务架构模式应用在敏捷开发和交付复杂的企业应用程序的时候还是有巨大优势的 。</p>
<p>这篇博客是设计、构建和部署微服务七篇博客系列之一。通过该文章将学到一些微服务的方法，还有微服务架构与传统的整体式架构模式的比较。本系列将介绍微服务架构的各种元素，并揭示该架构模式的各种优点与缺点，以此来指导微服务是否适合您的项目，以及如何运用该模式。</p>
<p>让我们首先看看为什么你应该考虑使用微服务。</p>
<h2 id="构建整体式应用"><a href="#构建整体式应用" class="headerlink" title="构建整体式应用"></a>构建整体式应用</h2><p>假设现在我们为了与Uber和Hailo竞争来构建一个全新的出租车品牌<strong>taxi-hailing</strong>:经过一系列的预备会议和需求收集，我们决定无论是人工撸还是用Rails，Spring Boot，Play，或Maven之类工具生成也好，最终要创建一个全新的应用！应用应该有如下图六边形一样的模块结构</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3912920-d319c7769ff1e518.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>应用程序的核心是业务逻辑，它了定义服务、 领域对象和事件模块。围绕核心是接口与外部世界的适配器。适配器的例子包括数据库访问组件、 生产消息和消费消息的消息传递组件以及暴露API或实现用户界面的 web 组件。</p>
<p>尽管在逻辑上模块化，整个应用还是做为一个巨大的整体进行打包和部署的。而且模块的结构往往与选择的编程语言和框架紧密相关。 举个栗子： 多数java程序打成war包部署到Tomcat 、Jetty等应用服务器中；还有一部分被打成自包含的jar包（Spring Boot支持把jetty或者tomcat包进去，以main为入口启动应用）； 同样的，Rails 和 Node.js 应用直接以目录结构的方式部署.</p>
<p>这种风格开发的应用是非常常见的。我们的IDE和工具致力于构建这样的单一应用，所以我们开发起来也感觉到简单；此类应用测试起来也很方便，你可以很简单的启动这个应用，采用selenium测试UI去完成端到端的测试；单体应用部署起来也不难，把包一拷贝扔服务器里就妥了， 如果要扩展应用，只需要在负载均衡器后面跑多个相同的应用就可以了。工程的初期呢，这个方法工作的还是不错的！</p>
<h2 id="迈向单体的地狱"><a href="#迈向单体的地狱" class="headerlink" title="迈向单体的地狱"></a>迈向单体的地狱</h2><p>很不幸的是，这种方式还是有巨大的局限性的.。一个成功的应用总会随着时间逐步成长并变得巨大起来。每个敏捷Sprint周期，开发者会实现更多的功能，当然这就意味着又添加了很多行代码。几年之后你会发现，当年你写的那个简单的小小的应用居然变成一个巨大的单体怪物。举一个比较极端的例子吧：最近我和一个开发者聊天，他正在写一个工具来分析数百万行代码的巨大应用中的上千个jar的依赖关系。别的不说，写出这么巨大的怪物肯定花费了很多程序员几年的时间。</p>
<p>一旦应用变成了巨大复杂的单体，那你的开发团队将痛苦不堪！敏捷开发和交付的一些愿景在这个庞然大物面前都会受挫。最主要的问题就是这玩意儿现在太复杂了！复杂到很难有某个程序员能完全理解它！导致结果就是，正确的修个bug、做个新功能变的费时又费力。更可恨的是，这是一个恶性循环的过程，应用正在逐步的‘死去’ 。如果你的代码库别人都理解不了，那么对代码做点正确的改动是很难的，最终这个怪物更加的可怕更加的难以理解，纠结！</p>
<p>应用程序的规模大了也会拖慢程序的开发： 程序越大，启动越慢！调查显示一些程序员说他们启动程序要12分钟，我个人还听过有的应用启动要40分钟！程序员开发过程需要周期性的重启应用，这样就浪费了很多时间，效率自然也很低下，不能忍！</p>
<p>巨大、复杂的单体应用还是持续交付的巨大障碍。现在SaaS应用的宗旨是如果有改动能够每天部署多次。单体应用的中某部分的改动需要需要重新部署整个应用，这样的话持续交付是相当困难的。前面也讲了，启动一次就要那么久 ！另外，改动造成的影响也不是很好被理解，需要大量的手工测试去保证，这样的话持续交付更是难上加难了！</p>
<p>单体应用在多个模块对资源需求上有冲突时很难进行扩展。比如：一个新模块可能实现了CPU密集型的图片处理逻辑,更适合部署到Amazon EC2 Compute Optimized instances。另一个模块可能需要一个内存数据库，更适合使用EC2 Memory-optimized instances。然而，这些模块必须被一起部署的话，选择硬件的时候就要好好折中一下喽。</p>
<p>单体应用的另一个问题是稳定性：因为所有的模块都跑在同一进程之中，某模块中的bug，比如内存泄漏是可能拖垮整个应用的！更重要的是，因为负载均衡后面的所有的应用是一样的，bug还可能影响整个应用的可用性！</p>
<p>最后重要的一点：单体应用很难拥抱新的框架和编程语言。假设你有2百万行用XYZ框架写的代码，如果用ABC框架重写它将会耗费巨大的时间和金钱！哪怕大家都知道用新框架更适合一些（摊手）。这样导致的结果是，在尝试转换新框架新技术的时候存在巨大的障碍，我们不得不继续在选型之初定好的技术架构上前行（哭脸）。</p>
<p>最后总结下吧，你从拥有一个业务清晰，几个程序员都明白的小程序，逐步的变成了一个可怕的单体应用。回首看这个应用是采用了过时的、效率低下的技术来写的（毕竟技术在进步，抱着老东西闷头陶醉不是什么好事情）！别的不说，招聘都费劲呐！这个单体应用变的难以扩展、变得极不稳定，想敏捷开发？想持续交付？ 恐怕只能呵呵了。</p>
<p>面对这些，你能做点什么呢？</p>
<h2 id="微服务-–-处理这些复杂问题！"><a href="#微服务-–-处理这些复杂问题！" class="headerlink" title="微服务 – 处理这些复杂问题！"></a>微服务 – 处理这些复杂问题！</h2><p>很多机构，比如Amazon、eBay、Netflix，已经开始通过拥抱微服务架构去解决上述的问题了。她们不再去构建一个可怕的单体应用，而是拆分成多个更小的、相互连接的微服务！</p>
<p>服务通常实现了一系列相互独立的功能或特性，比如订单管理、客户管理等等。每一个微服务都具有自身业务逻辑以及各种适配器构成的六角形架构模式，都是一个迷你的小应用。有的微服务会暴露API供其他微服务和客户消费，其他微服务则可能实现Web UI。运行时，每一个实例通常是云平台的一个VM或者一个Docker容器。</p>
<p>下面是对上述老架构的一个拆分：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3912920-9762019e56935c8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>应用的每个功能区域限制都以微服务的方式来实现了，此外整个应用被拆分成一系列更小的web应用（比如乘客管理、司机管理）。拆分之后更加方便的为特殊用户、设备或者特殊用例进行部署。</p>
<p>每一个后端服务暴露REST API，绝大部分服务也会消费其他服务提供的API。比如，司机管理服务会使用通知服务告知空闲的司机潜在的行程（来生意了，接单！）；还有UI 服务会调用其他服务后渲染web页面。服务之间也会使用异步的，基于消息的通信模式，服务内的通信将会在后面的文章详述。</p>
<p>一些REST API 也会暴露给移动端设备方便司机和乘客的使用。当然，这些应用不会直接访问后端各个微服务 ，而是通过一个协调者<strong>API网关</strong>来访问的。 API网关的职责有负载均衡、缓存、访问控制、API计费、监控···，这些事情使用NGINX就OK啦。后面的文章将会讲述API网关的细节。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3912920-edd018002c577cff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>微服务架构模式很契合上图的Y轴扩展方式，上图X轴的扩展表示横向扩展应用，一般就是负载均衡器后面部署几个相同的应用。Z轴扩展表示数据分区,将请求路由到特定的服务器上（比如数据库分库分表，根据主键访问到用户记录对应的数据库）。</p>
<p>应用一般都会三个维度去扩展。Y轴正是按照我们第一节讲到的，把单体应用拆分为微服务，运行时呢，为了某个服务达到高吞吐和高可用性，可以采用负载均衡，也就是X轴扩展了，特殊应用也会使用Z轴扩展来切分服务。下面的图展示了行程管理采用Docker镜像部署到Amazon EC2的情况：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3912920-2d3f5e1b1c954c35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>运行时，行程管理由多个服务实例组成。每个应用实例实际是一个Docker容器。为了达到高可用，容器会跑在多个云平台VM上，服务实例之前是NGINX这样的负载均衡器来分发请求，负载均衡器也会关注比如缓存、权限访问、服务计费、监控等事宜。</p>
<p>微服务架构模式极大的影响应用和数据库之间的关系。每个微服务都会有自己的数据库Schema，而不是和其他服务共享一套数据库Shcema。另一个角度看，这种方式对于以往企业级范围的数据模型来讲是很奇怪的，另外，微服务这么搞会造成数据冗余。然而，如果你想从微服务架构获益，那么每个微服务一个数据Schema是很有必要的，因为微服务提倡的就是松耦合啊，下面的图展示了微服务架构下应用的数据架构：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3912920-609da44e77622fea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>每个微服务都有自己的数据库，而且每个服务还能选择适合自己需求的数据库，这就是所谓的多态型持久化架构。比如，司机如果需要查找附近的潜在乘客，那就必须要使用支持高效地理位置查询的数据库。</p>
<p>表面上看微服务和SOA架构很相似，两种架构都倡导由一系列的服务组成。我们可以把微服务架构模式当成是没有商业web service规范（WS规范咯）以及ESB等打包的套件约束的SOA。基于微服务架构的应用更倾向于简单的、轻量级的REST协议而不是老旧的WS，当然，微服务也会避免去使用笨重的ESB套件而更喜欢去实现一些ESB部分功能的轻量级工具（不要捆绑，不要全家桶！），微服务架构模式也避免SOA中诸如规范化Schema的定义。</p>
<h2 id="微服务的优势"><a href="#微服务的优势" class="headerlink" title="微服务的优势"></a>微服务的优势</h2><p>微服务架构模式有很多重要的优势。首先，通过把可怕巨大的单体拆分为一系列的服务解决了单体复杂度问题， 拆分后整体功能数量并没有变化，但是应用现在变成了多个方便管理的小应用，每个服务都有一个定义良好的服务边界，通过RPC方式或消息驱动暴露API。微服务架构模式解决了单体应用代码库在实践中极难模块化的难题，拆分后的微服务能够更快的部署，更易理解和维护！</p>
<p>第二，拆分后的服务可以被专注于某部分服务的团队独立开发。程序员可以基于API约定前提下自由选择合适的技术，当然，很多机构为了避免技术选择混乱也会限制技术的选项。因此，自由意味着程序员可以不再局限于项目初期选择的技术了（撒花）！开始写一个新的微服务的时候，开发者可以使用一些当下流行的技术，更重要的是，因为每个服务现在拆分的很小，使用现有技术重写老的服务成为可能！</p>
<p>第三，微服务架构模式使得独立部署成为可能，开发者不用再忙碌于协调其他模块的变化再去部署（单体应用，改一个部分可能对其他部分影响，某个更改可能涉及多个模块的协调），微服务的更改可以在测试后尽快的被部署。比如，UI组可以进行A/B测试并且快速迭代而不用等待整个应用部署。微服务架构模式使得持续部署成为可能！</p>
<p>最后，微服务架构模式使得每个服务可以独立的扩展。我们可以针对某些有容量和可用性要求的微服务进行扩展，为需要的服务部署多个实例而不是复制多个单体去折中获得某项提升！更重要的是，我们可以针对服务需求使用最合适的硬件资源。比如，我们可以把CPU密集型的图片处理服务部署到EC2 Compute Optimized instances，部署内存数据库相关的服务到EC2 Memory-optimized instances。</p>
<h2 id="微服务的劣势"><a href="#微服务的劣势" class="headerlink" title="微服务的劣势"></a>微服务的劣势</h2><p>正如Fred 30年前的书中所说,“没有银弹！”。和其他技术一样，微服务架构也有其劣势 。劣势之一就是它的名字（捂脸），微服务这个词过分强调了服务的尺寸，实际上还真有几个开发者号召大家写10-100行代码的‘微服务’（这应该不太可能吧）！然而微服务更想表达的是一种工具和途径，微并不是最终的目标（为微服务而微服务，敲响警钟），微服务是为了便利敏捷开发和部署而去有效的拆分应用。</p>
<p>微服务另一个劣势是因为从单体应用拆分为分布式系统带来的复杂。开发者需要选择或者实现基于消息或者RPC模式的进程间通讯机制，另外开发者也要写额外的代码去处理对于目的服务请求可能存在的请求缓慢或者请求不可用导致的部分失败问题。分布式系统可不是什么火箭科学，它可比单体应用中模块间通过语言层面或者进程内调用复杂的多了！</p>
<p>微服务另一个挑战就是拆分数据库架构。一个逻辑事务更新多个业务记录是很常见的事情，单体应用实现该事务是比较简单的，毕竟大家使用一个数据库。然而在微服务架构中，你必须要更新多个服务的多个数据库。一般不会使用分布式事务，不仅仅是因为CAP理论，还因为一些流行的NoSQL数据库和Message Queue系统压根也不支持（摊手）。最后还得绕回最终一致性方案，这个方案对开发者来讲也是略有挑战的（实际上我看这个系列的文章并且开始翻译也是因为实际中遇到了这个问题，下面的文章将会提到）。</p>
<p>测试微服务架构的应用也是更加复杂的。比如，使用Spring Boot这种框架，开发者启动一个单体应用去写一些测试用例、测试其REST API是很平常事情。相反的是，相类似的测试在微服务中的话，你要启动或者至少去mock其依赖的其他的服务才能完成。再次强调，微服务不是火箭科学，很重要的一点是大家不要低估了这样做的复杂度！</p>
<p>微服务架构模式的另一巨大挑战是实现跨服务的改动。比如，让我们假设你要实现一个需要更改服务A、B、C的功能，而此时A依赖于B，B依赖于C。在传统单体应用中，你可以很简单的去更改对应的模块，集成这些变动然后一起部署它们。然而在微服务架构模式下，你需要小心翼翼的计划和协调每个服务的改动和发布：你需要更新服务C，再更新服务B。然后还要更新服务A。幸运的是，绝大部分时候一个服务的变化仅会影响一个服务，多个服务间需要协调的情况是很少出现的。</p>
<p>部署一个基于微服务架构的应用是更加复杂的。一个传统单体应用可以简单的部署到负载均衡器后面，因为应用都是相同的，拷贝部署就可以了。每个应用配置好数据库和message broker的地址（主机和端口）就好了。相对应的微服务一般是大量的服务组成的，比如，Hailo存在160个不同的服务，Netflix则有多达600多个不同服务，每个服务还有多个运行实例！将会有更多的变化的部分需要去配置、部署、扩展、监控。此外还需要实现一个服务发现机制让其他服务找到它需要通信的服务的地址。传统的基于Ticket和手动运维的方式是不可能处理好这个级别的复杂扩展的。因此，成功部署一个微服务需要开发者对部署方法有更多控制还要对服务执行高水平的自动化。</p>
<p>自动化的其中一种方式是使用现有的Paas平台（比如Cloud Foundry）。PaaS平台为开发者提供了便捷的方式去部署他们的微服务，避免了是他们纠缠于购买和配置IT资源的泥潭。同时，配置PaaS系统和网络的专业人员可以确保遵守了最佳实践和公司策略。另一种自动化方式就是开发自己的PaaS平台。一个典型的开端就是先使用集群方案（比如Kubernetes）配合上Docker容器技术，后续的文章将会介绍基于软件的应用部署方案，比如NGINX是如何在微服务层面方便的处理缓存、访问控制、API计费、监控等问题的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>构建复杂的应用本身就是困难的事情。单体应用架构在针对简单、轻量级的应用的时候是很好的。但是一旦你把那套方案运用在复杂的应用的时候你将会痛苦不堪。尽管微服务架构模式有诸多缺点和实现上的挑战，但对于复杂的、演进的应用来讲是一个更好的选择。</p>
<p>在后续的文章中我将会详细介绍微服务的几个方面，讨论一些诸如服务发现、服务部署选择以及重构单体应用到微服务的的话题。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>第一篇文章翻译完了，说实话胆颤心惊，第一次作大死，厚着脸皮上吧！！！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/04/microservices/Event-Driven Data Management for Microservices/" itemprop="url">
                  微服务之事件驱动的数据管理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-01-04T13:36:23+08:00" content="2017-01-04">
              2017-01-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/microservice/" itemprop="url" rel="index">
                    <span itemprop="name">microservice</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>原文链接:<a href="https://www.nginx.com/blog/event-driven-data-management-microservices/?utm_source=introduction-to-microservices&amp;utm_medium=blog&amp;utm_campaign=Microservices" target="_blank" rel="external"><em>Event-Driven Data Management for Microservices</em></a></strong></p>
<ol>
<li><em><a href="http://www.jianshu.com/p/8d2cfa1fa633" target="_blank" rel="external">微服务介绍</a></em></li>
<li><em><a href="http://www.jianshu.com/p/9e90b2a5df7b" target="_blank" rel="external">构建微服务之使用API网关</a></em></li>
<li><em><a href="http://www.jianshu.com/p/9c03081bc0d9" target="_blank" rel="external">构建微服务之:微服务架构中的进程内通信</a></em></li>
<li><em><a href="http://www.jianshu.com/p/1bf9a46efe7a" target="_blank" rel="external">微服务中的服务发现</a></em></li>
<li><em>微服务之事件驱动的数据管理(本文)</em></li>
<li><em><a href="http://www.jianshu.com/p/31c2a5a8b764" target="_blank" rel="external">选择一种微服务部署策略</a></em></li>
<li><em><a href="http://www.jianshu.com/p/29f4d788e3bb" target="_blank" rel="external">重构单体应用到微服务</a></em></li>
</ol>
<p>这是使用微服务架构构建应用系列的第五篇文章.第一篇文章介绍了微服务架构模式并讨论了使用微服务的优势和劣势 ；第二篇和第三篇文章讨论了微服务架构不同层面的通信问题；第四篇文章密切探讨了服务发现的相关问题；本文章呢，我们换个口味，看看微服务架构模式中的分布式的数据管理问题。</p>
<h2 id="微服务与分布式数据管理问题"><a href="#微服务与分布式数据管理问题" class="headerlink" title="微服务与分布式数据管理问题"></a>微服务与分布式数据管理问题</h2><p>一个单体应用一般只有一个关系型数据库，使用一个关系型数据的优势是应用可以实现ACID，为业务操作进行保证：</p>
<ul>
<li>Atomicity – 操作是原子性的</li>
<li>Consistency – 数据库中的状态永远是一致的</li>
<li>Isolation – 尽管事务是并发的执行，但他们表现的像顺序执行，事务之间不会彼此影响</li>
<li>Durable – 一旦事务提交就不能再撤销</li>
</ul>
<p>因此，应用可以很简单的开始一个事务，操作（增删改）多条数据，然后提交事务。</p>
<p>使用关系型数据库的另一个巨大优势是可以使用SQL，一种丰富的声明式的标准查询语言。 你可以很简单的写一条关联多个数据表的查询语句，关系型数据库管理系统会解析SQL来决定最优执行方案执行该查询。你不必关心诸如数据库如何访问这种低层次的细节问题，另外，你所有的应用数据在一个数据库中，查询起来很容易。</p>
<p>很不幸的是，当转换到微服务架构的时候，数据访问变的越来越复杂。这是因为每个服务拥有的数据是该服务所私有的，要想访问该服务的数据只能通过API。对数据进行封装可以确保微服务之间是松散耦合的，各个服务可以独立于其他服务进行演进。如果多个服务访问同样的数据，那么Schema的更新是很耗时而且需要协调所有服务进行更新。</p>
<p>不同微服务可能使用不同的数据库会让事情变得更糟。现代应用程序存储和处理各种各样的数据，关系数据库并不总是最好的选择。在一些用例下，一种特殊的NoSQL数据库可能有更加方便的数据模型并且提供更好的性能与扩展性 ，比如，对一个存储和查询文档的服务来讲，使用Elasticsearch这样的文档查询引擎可能更加合适；同样的，存储社交图谱的服务更合适使用Neo4J这样的图数据库 。总之，微服务架构的应用经常使用SQL和NoSQL的混合存储，通常叫做多态型数据持久性方案。</p>
<p>一个分区的多态型的数据持久性方案有诸多好处：松耦合、更高的性能、扩展性等，然而这也引入了分布式数据管理的挑战！</p>
<p>第一个挑战就是如何跨多个服务实现业务事务、维护数据的一致性。为什么这是一个问题？让我们看一个在线B2B商店的例子：用户服务维护诸如用户信用额度这样的信息，订单服务管理订单并且确保新订单没有超过用户的信用额度限制。在传统单体应用中，订单服务可以在创建新订单时简单的使用ACID事务去查看用户可用的信用额。</p>
<p>然而在微服务架构中，<strong>ORDER</strong> 和<strong>CUSTOMER</strong>表是各个服务所私有的，如下图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3912920-39d62663419d03a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>订单服务不能直接去访问用户表而只能使用用户服务提供的API。订单服务可能潜在的使用分布式事务，也就是两段提交，然而现在的应用中两段提交通常不是一个可行的选择。CAP理论要求你在可用性和ACID风格的一致性之间进行选择 ，而且。许多流行的技术，比如NoSQL并不支持两段提交，这就尴尬了！维护跨服务和跨数据库的数据一致性是很有必要的，所以我们需要另一种解决方案。</p>
<p>另一项挑战就是如何在多服务中获取数据。比如。假设我们应用需要展示用户信息和他最近的订单，如果订单服务提供API查询用户订单，那么你可以使用 应用程序连接查询数据 ：应用从用户服务查询用户信息，从订单服务查询订单。 假设，订单服务仅支持主键查询订单（也许使用了仅支持主键查询的NoSQL），这种情况下，没有好的方法来检索数据。</p>
<h2 id="事件驱动架构"><a href="#事件驱动架构" class="headerlink" title="事件驱动架构"></a>事件驱动架构</h2><p>对很多应用来讲，方案就是使用事件驱动架构。在该架构中，一个微服务在一些业务发生时发布一个事件，比如更新一条业务记录，其他微服务会订阅该事件，当微服务收到事件后会更新自己的业务记录，导致其他的事件被发布。</p>
<p>你可以使用事件实现跨服务的业务事务。一个事务包含一系列步骤，每个步骤由某微服务更新业务记录并发布事件触发下一步骤组成。下面的图显示如何使用事件驱动方式在创建订单时检查可用信用额度 ，微服务间通过Message Broker交换事件。</p>
<ol>
<li>订单服务创建状态为NEW的订单并发布<strong>Order Created</strong>事件<br><img src="http://upload-images.jianshu.io/upload_images/3912920-c34e0260f81ba3ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></li>
<li>客户服务消费<strong>Order Created</strong>事件，为该订单预订信用并发布<strong>Credit Reserved</strong>事件<br><img src="http://upload-images.jianshu.io/upload_images/3912920-c8a5730c151bf778.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></li>
<li>订单服务消费<strong>Credit Reserved</strong>事件并更改订单状态为<strong>OPEN</strong><br><img src="http://upload-images.jianshu.io/upload_images/3912920-9f629b3f80489e19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></li>
</ol>
<p>更复杂的场景可能调用多个步骤，比如保留订单同时检查用户信用。</p>
<p>假设（a）每个服务原子性的更新数据库并发布事件– 并且–  （b） Message Broker保证事件至少被交付一次，那么你就可以实现跨服务的业务事务了。我们必须注意到一点是，这并不是ACID事务，他们提供更弱一点的最终一致性，这种事务模型可以参考 <a href="http://queue.acm.org/detail.cfm?id=1394128" target="_blank" rel="external">BASE model</a>.</p>
<p>你也可以使用事件来维护提前关联了多个微服务的物化视图。该服务通过订阅相关事件并更新视图，比如，用户订单视图通过订阅订单事件和用户事件来更新用户订单视图。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3912920-24785400e0d9fbd4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>当客户订单视图更新服务接收到来自客户或者订单的事件时，它将更新客户订单视图。你可以使用Mongodb这样的文档数据库为每个用户存储一份文档来实现客户订单更新视图，客户订单视图查询服务可以查询客户订单视图数据库提供客户信息与最近客户订单数据。</p>
<p>事件驱动架构有很多优势也有一些劣势。它使得跨服务事务成为可能，并提供了最终一致性，另一个优势就是它使得应用可以维护物化视图；但是劣势之一是编程模型比ACID事务模型更为复杂 ，通常我们要实现补偿事务来恢复应用级别的错误。比如，一旦信用额度确认失败，你必须要取消订单，并且应用要处理不一致的数据， 这是因为随意的事务是可见的，应用如果读取未更新的物化视图，将会获取到不一致的数据，另外一个劣势是，订阅必须可以检测并忽略重复的事件。</p>
<h2 id="实现原子性"><a href="#实现原子性" class="headerlink" title="实现原子性"></a>实现原子性</h2><p>在事件驱动的架构中，还有一个更新数据与发布事件的原子性问题。比如，订单服务需要插入一条数据到 <strong>ORDER</strong>表并且发布<strong>Order Created</strong>事件，这两个操作原子性完成是很有必要的：假如在数据库更新完成后，事件发布之前服务挂掉了，系统将会存在不一致。标准确保原子性的方式是使用分布式事务调用数据库系统和Message Broker。然而，根据前面我们描述的理由，比如CAP理论，我们是想避免这么干的。</p>
<h2 id="使用本地事务发布事件"><a href="#使用本地事务发布事件" class="headerlink" title="使用本地事务发布事件"></a>使用本地事务发布事件</h2><p>应用发布事件并保证原子性的方法之一是采用多步骤本地事务方法。技巧是有一张EVENT表，表其实就是模拟一个message queue。当然数据库中还存着业务数据的状态，应用开始一个本地数据库事务，更新业务数据记录并往EVENT表中插入一条数据，最后提交事务。一个单独的应用线程或进程轮询EVENT表，并根据查询结果往Message Broker推送事件消息，然后使用本地事务标记事件被发布。下图描述了该设计：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3912920-db0c3e03d9744d32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>订单服务插入数据到ORDER表并且插入Order Created event 到EVENT表。数据发布者线程或进程轮询EVENT表中未发布的事件，发布事件，然后更新EVENT表标记事件已被发布。</p>
<p>这种方案有优势也有劣势。优势之一是保证了在不使用两段提交前提下事件在每次更新后一定被发布 ，当然，应用发布了业务级别的事件，减少了再去推断事件类型的麻烦。劣势之一是这种方案很容易出错，因为要求程序员必须记得更新后去发布事件，该方案另一个局限是使用NoSQL时，由于NoSQL的事务和查询能力局限，实现起来困难。</p>
<p>这种方案使用本地事务来更新数据和发布事件减少了两段提交的使用，现在让我们来看只需更新状态就达到原子性的方法。</p>
<h2 id="挖掘数据库事务日志"><a href="#挖掘数据库事务日志" class="headerlink" title="挖掘数据库事务日志"></a>挖掘数据库事务日志</h2><p>另一种不需要两段提交就实现原子性的方法是挖掘数据库事务日志或提交日志实现事件发布,这就要求变化操作要被记录在数据库事务日志当中，事务日志挖据线程或进程读取事务日志并发布事件到 Message Broker。下图展示了这种方案：<br><img src="http://upload-images.jianshu.io/upload_images/3912920-e1633250c639939c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>例子之一就是开源的<a href="https://github.com/linkedin/databus" target="_blank" rel="external">LinkedIn Databus</a> 项目。 Databus 挖掘 Oracle事务日志并发布相应的事件， LinkedIn使用 Databus 来保持各种派生数据存储与记录系统的一致。</p>
<p>另一个例子就是NoSQL数据库<a href="http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Streams.html" target="_blank" rel="external">streams mechanism in AWS DynamoDB</a>， DynamoDB 流包含在过去 24 小时向 DynamoDB 表中的记录所做的时序性变化 （创建、 更新和删除操作）。应用程序可以从流中读取这些更改并将它们作为事件发布。</p>
<p>事务日志挖掘有优势也有劣势。优势之一是在不使用两段提交的前提下保证了事件一定被发布，事务日志挖据也可以通过拆分应用业务逻辑事件的发布简化整个应用。该方案一个巨大的劣势是：事务日志每个数据库都不同，甚至相同数据库不同版本也会不同（摊手），而且我们很难从低级别事务日志的更新记录中反推高级别的业务事件。</p>
<p>事务日志挖掘通过更新数据库来避免使用两段提交。现在让我们看看一种消除了更新，并完全依靠的事件的方案：</p>
<h2 id="使用事件源"><a href="#使用事件源" class="headerlink" title="使用事件源"></a>使用事件源</h2><p>事件源通过使用截然不同，以事件为中心的方案持久化业务实体，达到了不使用两段提交前提下 的原子性。这种方案存储一系列状态变化的事件而不是存储当前实体的状态。应用可以通过重放事件来重新构建实体的当前状态。一旦业务实体发生变化，一个新的事件就会被添加到事件列表中，由于保存事件是单一操作，本身就是原子性的。</p>
<p>为查看事件源如何工作，我们以订单实体为例子。传统方案下，每个订单会映射到ORDER表并记录数据到ORDER_LINE_ITEM。但当使用事件源编程时，订单服务以存储订单状态变化事件来存储订单：订单创建、批准、运输、取消。每个事件有充足的信息来重新构建订单。<br><img src="http://upload-images.jianshu.io/upload_images/3912920-af829ed8264d124b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>事件存储到专门存储事件的数据库中，数据库提供添加和查询实体事件的API。这个事件数据库也会像我们上面描述的Message Broker一样提供让其他服务订阅事件的API，事件数据库向对其感兴趣的订阅者发布事件，这个事件数据库是事件驱动型微服务的骨架。</p>
<p>事件源的优势：它解决了一个实现事件源架构的关键问题，使得事件发生时可靠的发布事件成为可能，因此，它解决了微服务架构中数据一致性的问题。当然，因为他持久化事件而非领域对象，也避免了面向对象到关系型数据库中的阻抗不匹配问题。事件源也为实体变动提供了100%可靠的审计日志，并使其能够执行可以确定在任何时间点实体状态的时态查询。事件源的另一巨大优势是，业务逻辑与交换事件的实体是松耦合的，这使得迁移一个单体应用到微服务架构更加简单。</p>
<p>事件源也有一些劣势：对程序员来讲这是完全不同的，非常陌生的编程风格，学习曲线陡峭。事件数据库仅仅直接支持主键方式查询业务实体，必须使用 <a href="https://github.com/cer/event-sourcing-examples/wiki" target="_blank" rel="external">Command Query Responsibility Segregation</a> (CQRS) 来实现查询。因此，应用必须来处理最终一致性。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在微服务架构中，每个服务拥有自己的数据存储。不同服务可能是一不同的SQL或者NoSQL数据库。这样的数据库架构有很多优势，当然也带来了分布式数据管理的挑战。挑战之一就是如何实现跨多服务的业务逻辑事务来维持一致性，挑战之二就是如何从多服务查询数据。</p>
<p>对很多应用来讲，使用事件驱动架构来应对这些挑战。实现事件驱动架构的挑战之一是如何保证更新数据状态和发布事件的原子性 ，有几种方案来实现，包括以数据库为message queue，事务日志挖掘，事件源。</p>
<p>剩余的文章将讨论其他方面的问题。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/04/microservices/Choosing a Microservices Deployment Strategy/" itemprop="url">
                  选择一种微服务部署策略
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-01-04T13:36:23+08:00" content="2017-01-04">
              2017-01-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/microservice/" itemprop="url" rel="index">
                    <span itemprop="name">microservice</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>原文链接:<a href="https://www.nginx.com/blog/deploying-microservices/?utm_source=introduction-to-microservices&amp;utm_medium=blog&amp;utm_campaign=Microservices" target="_blank" rel="external"><em>Choosing a Microservices Deployment Strategy</em></a></strong></p>
<ol>
<li><em><a href="http://www.jianshu.com/p/8d2cfa1fa633" target="_blank" rel="external">微服务介绍</a></em></li>
<li><em><a href="http://www.jianshu.com/p/9e90b2a5df7b" target="_blank" rel="external">构建微服务之使用API网关</a></em></li>
<li><em><a href="http://www.jianshu.com/p/9c03081bc0d9" target="_blank" rel="external">构建微服务之:微服务架构中的进程间通信</a></em></li>
<li><em><a href="http://www.jianshu.com/p/1bf9a46efe7a" target="_blank" rel="external">微服务中的服务发现</a></em></li>
<li><em><a href="http://www.jianshu.com/p/9a440c5ea1db" target="_blank" rel="external">微服务之事件驱动的数据管理</a></em></li>
<li><em>选择一种微服务部署策略(本文)</em></li>
<li><em><a href="http://www.jianshu.com/p/29f4d788e3bb" target="_blank" rel="external">重构单体应用到微服务</a></em></li>
</ol>
<p>这是使用微服务架构构建应用系列的第六篇文章，第一篇文章介绍的微服务架构模式以及使用该模式的优势和劣势，接下来的文章讨论了微服务架构的不同方面：使用APi网关、进程间通信、服务发现以及事件驱动的数据管理。本篇文章我们将看一下有关微服务部署的策略。</p>
<h1 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h1><p>部署一个<a href="http://microservices.io/patterns/monolithic.html" target="_blank" rel="external">单体应用</a>意味着对一个一般比较庞大的应用运行多个相同的拷贝，通常需要提供N台服务器（物理机或者虚拟机），并在每一台机器上运行M个应用实例。部署一个单体应用一般并不是特别直接，但是相比部署微服务架构的应用来讲，它已经简单很多了。</p>
<p>一个 <a href="http://microservices.io/patterns/microservices.html" target="_blank" rel="external">微服务应用</a>包含数十个甚至上百个服务，服务是由多种不同的编程语言和框架写成，每一个服务都是一个有自己独特的部署、资源、扩展性以及 监控需求的mini应用。比如，你需要根据服务的需求对该服务运行一定数量的实例，而且，每一个服务实例必须提供适当的CPU、内存以及I/O资源，更加具有挑战性的是，尽管这很复杂，部署一个服务同时还要求 快速、可靠、高效。</p>
<p>存在多种微服务部署模式，让我们先看一下一台主机部署多个服务的模式：</p>
<h1 id="一台主机部署多服务实例模式"><a href="#一台主机部署多服务实例模式" class="headerlink" title="一台主机部署多服务实例模式"></a>一台主机部署多服务实例模式</h1><p>部署微服务的方法之一是使用<a href="http://microservices.io/patterns/deployment/multiple-services-per-host.html" target="_blank" rel="external">每台主机部署多服务实例</a> 的模式，使用这种模式的时候，你提供多台物理或者虚拟的主机，每台主机上运行多个服务实例，从某些角度来讲，这是传统的应用部署方式。每个服务的运行占用一台多多台主机上的端口，主机机器通常 <a href="https://www.nginx.com/blog/microservices-at-netflix-architectural-best-practices/?utm_source=deploying-microservices&amp;utm_medium=blog&amp;utm_campaign=Microservices#stateless-servers" target="_blank" rel="external">照顾宠物一样</a>来管理这些服务。</p>
<p>下图展示了这种模式的结构图：<br><img src="http://upload-images.jianshu.io/upload_images/3912920-2b381913e347ce3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>这种模式有多种变种，变种之一是每个服务对应一个或一组进程，比如你可能把一个java服务实例以web应用的形式部署到<a href="http://tomcat.apache.org/" target="_blank" rel="external">Apache Tomcat</a> 服务器中，一个<a href="https://nodejs.org/" target="_blank" rel="external">Node.js</a> 服务实例则可能包含一个父进程以及一到多个子进程。</p>
<p>这种模式的另外一个变种是在同一个进程或进程组中运行多个服务实例，比如你可以在同一个Apache Tomcat服务器中部署多个java web 应用，或者在同一个OSGI容器中运行多个OSGI bundles。</p>
<p>每个主机运行多个服务实例的模式有优势也有劣势。一个大的优势是资源利用率相当的高，多个服务实例共享服务器和对应的操作系统，如果一个进程或进程组运行多个服务实例的话，效率就更加高了，比如多个web应用共享同一台Apache Tomcat服务器和JVM。</p>
<p>该模式的另一个优势是部署服务实例相当的快速，你可以简单的把服务拷贝到主机并启动它。如果服务是java编写的，你拷贝JAR或者WAR包，如果是使用其他编程语言写的，比如 Node.js 或者 Ruby，你拷贝源代码就可以。在网络上拷贝这些字节的数量还是相对比较小的。</p>
<p>当然，由于没有其他的开销，启动一个服务一般是非常快的。如果该服务是其自身的进程，你只需要简单的启动进程，如果服务本身是运行于同一个容器进程或者进程组中的服务实例，你可以将其动态的部署到容器或者使用重启容器的方式启动服务。</p>
<p>尽管有一些魅力，每个主机运行多个服务实例的模式还是有一些重大缺陷的。一个主要缺陷是服务实例之间的隔离性很小或者没有隔离性，除非每个服务实例运行在单独的进程中！虽然你可以精确的监控每一个服务实例的资源使用情况，但你不可以限制每一个实例使用的资源，很有可能一个行为异常的服务实例会消耗掉主机上所有的内存和CPU资源。</p>
<p>同一进程运行多个服务实例的模式压根就没有隔离性，所有的服务实例可能共享相同的JVM heap，一个行为异常的服务实例可以很容易的破坏掉运行在同一进程中的其他服务实例，而且，你没有任何方法监控每一个服务实例的资源使用情况。</p>
<p>这种模式的另一个巨大劣势是对于运维团队来讲，部署一个服务实例必须知道针对该服务的具体细节，服务可能被不同的编程语言和框架写成，因此就有大量的细节需要开发人员分享给运维人员，这些复杂度增加了部署时出错的风险。</p>
<p>如你所见，尽管每个主机运行多个服务实例的模式很熟悉，但是存在一些严重的缺陷，现在让我们看一下可以避免这些问题的另一种模式：</p>
<h1 id="每个主机一个服务实例"><a href="#每个主机一个服务实例" class="headerlink" title="每个主机一个服务实例"></a>每个主机一个服务实例</h1><p>部署微服务的另一种模式是<a href="http://microservices.io/patterns/deployment/single-service-per-host.html" target="_blank" rel="external">每个主机一个服务实例</a> 模式。当你使用这种模式的时候，你可以隔离的在每一个主机中运行对应的服务实例，这种模式有两种不同的标准：每台虚拟机一个服务实例和每个容器一个服务实例。</p>
<h2 id="每台虚拟机一个服务实例模式"><a href="#每台虚拟机一个服务实例模式" class="headerlink" title="每台虚拟机一个服务实例模式"></a>每台虚拟机一个服务实例模式</h2><p>当你使用<a href="http://microservices.io/patterns/deployment/service-per-vm.html" target="_blank" rel="external">每台虚拟器一个服务实例</a> 模式的时候，你把每一个服务打包为一个虚拟机镜像，比如<a href="https://aws.amazon.com/ec2/" target="_blank" rel="external">Amazon EC2 AMI</a>。虚拟机中的每一个服务实例(比如， an EC2 instance)使用虚拟机镜像启动，下图展示了这种模式的架构：<br><img src="http://upload-images.jianshu.io/upload_images/3912920-2ad6d1e51505b3c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>这也是Netflix用来部署其video streaming服务的最初的方案。 Netflix使用 <a href="https://github.com/Netflix/aminator" target="_blank" rel="external">Aminator</a>把其每一个服务打包成EC2 AMI ，每一个运行的服务实例实际就是一个EC2实例。</p>
<p>有不同的工具可以让你构建自己的虚拟机镜像，你可以配置你的持续集成(CI)服务器(比如, <a href="https://jenkins-ci.org/" target="_blank" rel="external">Jenkins</a>) 调用Aminator来把服务打包成EC2 AMI。<a href="https://www.packer.io/" target="_blank" rel="external">Packer.io</a>是另一个自动化虚拟机镜像的选择，和Aminator不同，它支持不同的虚拟化技术，包括EC2、DigitalOcean、VirtualBox以及VMware。</p>
<p><a href="https://boxfuse.com/" target="_blank" rel="external">Boxfuse</a> 公司使用一种更加优秀的方式来构建虚拟机镜像，它克服了我下面将会讲到的虚拟机镜像的一些缺陷，Boxfuse把你的Java应用打包成一个迷你的虚拟机镜像，这些镜像可以被快速的构建、迅速启动，由于他们暴露了有限的可能被攻击的接口，所以也更加的安全。</p>
<p>每一台虚拟机一个服务实例的模式有一些优势。一个主要优势是每一个服务实例的运行都是相互隔离的，服务实例有固定的CUP和内存分配，它不可能窃取其他服务的资源。</p>
<p>该模式的另一优势是可以充分利用成熟的云平台基础架构，AWS这样的云平台都提供了负载均衡以及自动扩展这样的功能。</p>
<p>该模式的另一巨大优势是它封装了你服务实现使用的技术细节，一旦服务被打包成了虚拟机镜像，它就变成了一个黑盒，镜像管理API就成了服务部署API，部署变得更加简单和可靠。</p>
<p>一个虚拟机一个服务实例的模式也有有一些劣势，一个主要的劣势是资源利用率低，每一个服务都完全占有包括操作系统在内的整个虚拟机，更重要的是，在典型的公共IaaS中，固定大小的虚拟机资源并没有被充分利用。</p>
<p>然而，一个公共的IaaS平台在计费的时候并不关心虚拟机忙碌或空闲，AWS这样的IaaS平台提供自动扩展，但是<a href="http://techblog.netflix.com/2013/11/scryer-netflixs-predictive-auto-scaling.html" target="_blank" rel="external">很难快速响应并按需收费</a>，因此你需要经常的拨备虚拟机，增加了部署的花费。</p>
<p>这种方式的另一个劣势是部署一个新的服务通常非常缓慢。虚拟机镜像由于其大小的问题，构建过程非常缓慢，而且通常虚拟机的大小问题使得初始化也很缓慢 ，而且操作系统在启动的时候也要花费一定的时间，注意，这并不是指所有的镜像，因为还有Boxfuse这样的轻量级的虚拟机镜像存在。</p>
<p>这种模式的再一个劣势是你（或者你组中的其他人）需要负责大量非分化的heavy lifting。除非你使用诸如Boxfuse这样的工具处理构建和管理虚拟机镜像这些繁杂的事情，不然就只能是你来负责了，这些很必要但是又耗费时间的活动使你远离了你的业务代码。</p>
<p>让我们看下另一种具有虚拟机镜像优势同时更加轻量级的微服务部署方式吧：</p>
<h2 id="每台容器一个服务实例的模式"><a href="#每台容器一个服务实例的模式" class="headerlink" title="每台容器一个服务实例的模式"></a>每台容器一个服务实例的模式</h2><p>当你使用<a href="http://microservices.io/patterns/deployment/service-per-container.html" target="_blank" rel="external">每台容器一个服务实例</a> 模式的时候，每个服务实例运行在自己的容器中。容器是一种<a href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization" target="_blank" rel="external">操作系统层面的虚拟机制</a>，一个容器由跑在沙箱中的一到多个进程组成。从进程的角度看，他们都有自己的端口命名空间和根文件系统，你可以限制容器的内存和CUP资源使用。一些容器的实现也可以实现I/O的速率限制，容器技术包括<a href="https://www.docker.com/" target="_blank" rel="external">Docker</a> 和 <a href="https://en.wikipedia.org/wiki/Solaris_Containers" target="_blank" rel="external">Solaris Zones</a>。</p>
<p>下图展示了这种模式的架构：<br><img src="http://upload-images.jianshu.io/upload_images/3912920-ba65c5eab3c698bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>为使用这种模式，你需要把你的服务打包成容器镜像，一个容器镜像是包含运行服务所需应用和必要library的文件系统镜像，一些容器镜像可能包含完整的Linux根文件系统，比如为了部署一个java服务，你可以构建一个包含java运行时或者Apache Tomcat 服务器以及编译后的java应用的容器镜像。</p>
<p>一旦你把你的服务打包成了容器镜像，你就可以启动一到多个容器了，你通常在一台虚拟机或者物理机器上运行多个容器，你可以使用诸如<a href="http://kubernetes.io/" target="_blank" rel="external">Kubernetes</a> 或 <a href="https://github.com/mesosphere/marathon" target="_blank" rel="external">Marathon</a>这样的集群管理器来管理你的容器。集群管理器把这些主机作为资源池，它根据每台主机上的可用资源以及每台容器的资源需求决定把容器放置在哪台主机。</p>
<p>这种模式有优势也有劣势。优势类似于虚拟机具有的优势，他们隔离了每一个服务实例，你可以很容易的监控每一台容器的资源消耗，与虚拟机类似，容器也封装了实现服务所使用的不同技术细节，容器管理API同样作为管理服务的API来使用。</p>
<p>当然，不同于虚拟机，容器是更加轻量级的技术。容器镜像的构建通常非常快速，比如，在我的个人笔记本上，把一个<a href="http://projects.spring.io/spring-boot/" target="_blank" rel="external">Spring Boot</a> 应用打包为Docker镜像仅仅需要5秒钟。由于没有冗长的OS引导过程，容器启动过程也非常快速，容器启动，服务就会运行。</p>
<p>使用容器也有一些缺陷。尽管容器技术正在快速的走向成熟，但是相对虚拟机架构来说还是略显青涩，由于容器间分享同一主机的操作系统内核，容器并没有虚拟机那么安全。</p>
<p>容器的另一劣势是你必须负责管理容器镜像的这些未分化的heavy lifting，除非你使用诸如 <a href="https://cloud.google.com/container-engine/" target="_blank" rel="external">Google Container Engine</a> 或者<a href="https://aws.amazon.com/ecs/" target="_blank" rel="external">Amazon EC2 Container Service</a> (ECS)这些主机容器解决方案，你必须自己来管理容器的架构或者支撑容器的底层虚拟机架构。</p>
<p>此外，容器通常部署在按照每个VM定价的基础设施上，因此，正如前面提到的那样，为处理负载峰值的情况，你有可能为提供额外的虚拟机而增加额外的花费。</p>
<p>有意思的是，容器和虚拟机之间的区别变的模糊起来。前面提到Boxfuse虚拟机可以快速构建和启动， <a href="https://clearlinux.org/features/clear-containers" target="_blank" rel="external">Clear Containers</a> 工程致力于创建轻量级的虚拟机镜像。对于<a href="https://en.wikipedia.org/wiki/Unikernel" target="_blank" rel="external">unikernels</a>也有更多人感兴趣起来。 Docker公司最近收购了Unikernel Systems。</p>
<p>也有一种新的、逐步流行的server-less的部署理念，它回避了部署服务时选择容器还是虚拟机的问题，让我们接着看：</p>
<h2 id="Serverless-部署"><a href="#Serverless-部署" class="headerlink" title="Serverless 部署"></a>Serverless 部署</h2><p><a href="https://aws.amazon.com/lambda/" target="_blank" rel="external">AWS Lambda</a> 是serverless部署技术的例子之一，它支持Java、Node.js和Python 服务。为了部署一个微服务，你把服务打包为一个ZIP文件上传到AWS Lambda，你还要提供元数据，其中包括指定调用用以处理请求（也就是事件）的函数的名称 。 AWS Lambda自动为你的微服务运行足够的实例来处理请求。你可以简单根据每个请求花费的时间和消耗的内存进行计费。当然，你很快就会看到AWS Lambda在这些细节中的局限，但是请注意，不管你组织的开发者或者其他的人员都不需要担心服务器、虚拟机或者容器的各个方面，这一点是很有诱惑力的。</p>
<p>一个 <em>Lambda function</em> 是一个无状态的服务，它通常通过调用AWS服务来处理请求。比如，一个Lambda function在一张图片被上传到S3 bucket的时候被调用，它可能往DynamoDB图片表中插入一条记录并向Kinesis stream发送一条消息来触发图片的处理，一个Lambda function也可以调用第三方的web服务。</p>
<p>有四种调用Lambda function的方法:</p>
<ol>
<li>使用web服务请求直接调用</li>
<li>自动以响应诸如S3、DynamoDB、Kinesis或者Simple Email Service等产生的事件的方式调用</li>
<li>通过AWS API网关处理来自客户端的请求的方式调用</li>
<li>基于cron-like schedule阶段性的去调用</li>
</ol>
<p>如你所见，AWS Lambda 是部署微服务的一个方便方式，基于请求的计价意味着你只需要为你服务的实际工作买单，当然，你不必负责IT基础架构的问题，从而专心的开发你的应用。</p>
<p>当然，这也有显著的局限：它不是为部署需要长时间运行的服务而设计的，比如消费来自第三方消息中介的消息的服务。请求必须在300秒内被完成，由于理论上处理请求的AWS Lambda可能运行在不同的实例中，因此服务也必须是无状态的。它们必须使用被支持的编程语言所编写，服务必须快速被启动，否则将会超时或者终止。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>部署一个微服务应用是很有挑战性的，应用拥有十几个甚至上百个由不同编程语言和框架实现的服务组成，每一个服务都是一个拥有独特部署、资源、扩展和监控需求的迷你应用 。有每台虚拟机一个服务实例和每台容器一个服务实例两种微服务部署模式，另一种有趣的微服务部署选择是使用AWS Lambda，一个serverless的方式。在该系列下一篇也是最后一篇文章中，我们将讨论如何把单体应用迁移为微服务结构。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/04/microservices/Building Microservices-Using an API Gateway/" itemprop="url">
                  建微服务之使用API网关
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-01-04T13:36:23+08:00" content="2017-01-04">
              2017-01-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/microservice/" itemprop="url" rel="index">
                    <span itemprop="name">microservice</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>原文链接:<a href="https://www.nginx.com/blog/building-microservices-using-an-api-gateway/?utm_source=introduction-to-microservices&amp;utm_medium=blog&amp;utm_campaign=Microservices" target="_blank" rel="external"><em>Building Microservices: Using an API Gateway</em></a></strong></p>
<ol>
<li><em><a href="http://www.jianshu.com/p/8d2cfa1fa633" target="_blank" rel="external">微服务介绍</a></em></li>
<li><em>构建微服务之使用API网关(本文)</em></li>
<li><em><a href="http://www.jianshu.com/p/9c03081bc0d9" target="_blank" rel="external">构建微服务之:微服务架构中的进程间通信</a></em></li>
<li><em><a href="http://www.jianshu.com/p/1bf9a46efe7a" target="_blank" rel="external">微服务中的服务发现</a></em></li>
<li><em><a href="http://www.jianshu.com/p/9a440c5ea1db" target="_blank" rel="external">微服务之事件驱动的数据管理</a></em></li>
<li><em><a href="http://www.jianshu.com/p/31c2a5a8b764" target="_blank" rel="external">选择一种微服务部署策略</a></em></li>
<li><em><a href="http://www.jianshu.com/p/29f4d788e3bb" target="_blank" rel="external">重构单体应用到微服务</a></em></li>
</ol>
<p>对于设计、构建和部署微服务系列七篇文章的第一篇，我们介绍了微服务架构风格，讨论了微服务的优势和劣势，尽管微服务有些复杂，但仍然是构建复杂应用的一个明智选择，第二篇文章将讨论使用API网关构建微服务。</p>
<p>当我们选择把应用构建成一组微服务的时候，我们需要决定应用的客户端如何与这些微服务进行交互。传统单体应用中，往往只是一组（一般是replicated，负载均衡）的节点，而在微服务架构中，每个微服务都会暴露一组细粒度的节点。这篇文章中，我们将检验这种方式如何影响客户端与应用端的通信，并且提出使用API网关的方式来解决这个问题。</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>假设我们正在为一个商品应用开发一个原生移动客户端，我们应该提供一个产品明细页来展示指定产品的信息。<br>正如下图所示，当我们在亚马逊的安卓移动应用中滚动产品明细页时，它将会呈现给我们：<br><img src="http://upload-images.jianshu.io/upload_images/3912920-04d9729084dae96f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>尽管这是移动应用，产品明细页依然展示给我们很多信息，比如它不仅仅展示了产品的基本信息（比如名称、描述、价格等），还展示了：</p>
<ul>
<li>购物车中的条目数</li>
<li>订单历史记录</li>
<li>用户点评</li>
<li>低库存预警</li>
<li>配送选项</li>
<li>各项推荐,包括购买本产品还经常一起购买了其它某产品，客户买了这个产品同时还买了其他某产品，购买该产品的用户还浏览了哪些产品</li>
<li>替代购买选项</li>
</ul>
<p>当我们使用单体架构模式的时候，一个移动客户端可能通过发送单一的REST调用请求(GET api.company.com/productdetails/<em>productId</em>) 来获取展示的数据，负载均衡器会把该请求路由到多个相同应用实例的其中一台，应用继续查询不同的数据库表并返回请求数据给客户端。</p>
<p>对应的，在使用微服务架构模式的时候，需要在产品明细页展示的数据被多个微服务所拥有，下面是一些可能拥有需要展示数据在产品明细页的微服务：</p>
<ul>
<li>购物车服务：购物车中的产品条目</li>
<li>订单服务：订单历史</li>
<li>目录服务：基本产品信息，比如名称、图片、价格等</li>
<li>点评服务：用户点评</li>
<li>库存服务：低库存预警</li>
<li>配送服务：配送选项、时限以及来自配送提供者API计算出的费用</li>
<li>推荐服务：建议购买项<br><img src="http://upload-images.jianshu.io/upload_images/3912920-d2475b5d36a0f476.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>我们需要决定移动端如何访问这些服务，先看下面的选项：</li>
</ul>
<h1 id="客户端直接与微服务通信"><a href="#客户端直接与微服务通信" class="headerlink" title="客户端直接与微服务通信"></a>客户端直接与微服务通信</h1><p>理论上客户端可以直接与每一个微服务进行通信，每个微服务将会有一个公开的节点（<strong><a href="https://*serviceName*.api.company.name" target="_blank" rel="external">https://*serviceName*.api.company.name</a></strong>)），这个URL将会映射到负载均衡器，然后被分发到可用的实例上被处理，为了获取产品明细，移动客户端需要向上面列出的各个微服务发送请求。</p>
<p>非常不幸的是，这种方案有诸多挑战和限制，问题之一就是客户端与每个微服务暴露出的细粒度API之间的不匹配，本例子中的客户端需发送七个不同的请求，在一个更加复杂的应用中请求数可能更多，比如亚马逊在渲染产品页的时候可能要调用上百个服务来渲染页面，一个客户端可以在LAN中发送多个请求，但是在公网上就特别低效，那就不用提在移动设备上了，当然，这种方式也使得客户端异常的复杂。</p>
<p>客户端直接调用微服务的另一个问题是，一些服务可能使用对web并不友好的协议实现。一个服务可能使用Thrift二进制的RPC而另一个服务可能使用AMQP消息协议。这些协议都不是浏览器和防火墙友好的，最好是在应用内部被使用。防火墙之外呢，应用最好使用HTTP或者WebSocket。</p>
<p>这种方式另一个劣势是使得微服务重构变得困难，随着时间推移，我们可能需要重新划分、组织微服务，比如我们可能合并两个微服务，也可能把某微服务拆分为两个或多个，如果客户端直接与微服务交互的话，对这些微服务进行重构变得异常困难。</p>
<p>正是由于这些问题，采用客户端直接调用微服务的方式并不明智。</p>
<h1 id="使用API网关"><a href="#使用API网关" class="headerlink" title="使用API网关"></a>使用API网关</h1><p>通常更好的方式是使用大家都熟知的API网关，API网关是提供系统唯一入口的一台服务器，它和面向对象设计模式中的门面类似：API网关封装了内部的系统架构并向每个客户端提供裁剪的API，它也可能负责诸如用户验证、监控、负载均衡、缓存、请求改造和管理以及静态内容响应等职责。</p>
<p>下图展示了API网关通常适应的架构：<br><img src="http://upload-images.jianshu.io/upload_images/3912920-df6b13ad41a9ce3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>API网关负责请求路由、组合以及协议转换。所有来自客户端的请求都先经过API网关，然后被路由分配到相应的微服务中，API网关通常调用多个微服务并聚合其结果来处理请求，它可以在HTTP或者WebSocket这些web友好协议与内部使用的web不友好协议间相互转换。</p>
<p>API网关可以为每个客户提供定制化的API，它通常为移动客户端暴露粗粒度的API，比如提供（<strong>/productdetails?productid=<em>xxx</em></strong>）节点使得移动应用单一请求就能获取所有的产品明细。API网关调用产品信息、推荐、评分等服务，组合这些结果来处理客户端请求。</p>
<p>一个非常牛的例子就是Netflix API网关，Netflix 流服务在上百种包含电视、机顶盒、智能手机、游戏系统、平板电脑等设备上都可用。起初Netflix想为它们的流服务提供一种 <a href="http://www.programmableweb.com/news/why-rest-keeps-me-night/2012/05/15" target="_blank" rel="external">one‑size‑fits‑all</a> API，然而，他们发现由于设备的不同划分以及独特需求，这样设计是不现实的。现在他们使用API网关通过运行设备相关的适配器代码为客户端提供裁剪的API，适配器通常为每个请求调用平均六到七个后台服务， Netflix API网关现在每天处理上亿请求。</p>
<h1 id="使用API网关的优势与劣势"><a href="#使用API网关的优势与劣势" class="headerlink" title="使用API网关的优势与劣势"></a>使用API网关的优势与劣势</h1><p>正如你所想，使用API网关有优势也有劣势。一个巨大优势就是它封装了应用的内部结构，而不是让客户端直接调用每个服务，客户端只需要简单的与网关交互即可，另外API网关为不同客户提供定制的API，并且减少了客户端和应用间的网络调用，这也大大简化了客户端代码实现。</p>
<p>API网关也有一些劣势，它本身是一个新的高可用的组件，需要被开发、部署和管理，同时API网关有可能成为开发的瓶颈。开发者为了暴露新的微服务节点必须更新API网关，把更新网关的流程做的尽量轻量级是很重要的，不然的话，开发者更新网关的时候就要被迫在线等待。尽管它有这些劣势，在实战中，应用使用API网关还是明智的选择！</p>
<h1 id="实现一个API网关"><a href="#实现一个API网关" class="headerlink" title="实现一个API网关"></a>实现一个API网关</h1><p>现在我们讨论了API网关的动机和一些权衡，现在来考虑一些设计的问题吧：</p>
<h2 id="性能与扩展性"><a href="#性能与扩展性" class="headerlink" title="性能与扩展性"></a>性能与扩展性</h2><p>只有少数类似Netflix的公司需要每天处理上亿的请求，然而，对大多数应用来讲，API网关的性能和扩展性通常也非常的重要。在一个支持异步非阻塞IO的平台上构建API网关是明智的选择，我们有多种技术可以用来实现可扩展的API网关。基于JVM你可以选择基于NIO的诸如Netty、Vertx、Spring Reactor或JBoss Undertow等框架，Node.js也是一个流行的选项，它是一个构建于Chrome JS引擎的平台，另一选择是使用NGINX Plus，它提供了成熟、可扩展、高性能的web服务器和反向代理，并可以方便的被部署、配置和编程， NGINX Plus 可以管理用户校验、权限控制、请求负载均衡、响应缓存以及应用级别的健康检查和监控。</p>
<h2 id="使用响应式编程模型"><a href="#使用响应式编程模型" class="headerlink" title="使用响应式编程模型"></a>使用响应式编程模型</h2><p>API网关通过简单路由到相应后台服务来处理请求，通过调用多个后台服务并聚合结果来处理它。对于一些请求，比如产品明细请求，后端对应的服务是彼此独立的，为减少请求时间，API网关应该并行的处理这些请求。然而有时候，请求之间是有依赖关系的，API网关可能在路由请求到后台服务之前先去调用用户校验服务验证请求的合理性，类似的，在获取用户心愿单中的上的产品信息的时候，API网关必须先获取包含那些信息的用户档案再去获取每个产品的信息，另一个有趣的例子就是<a href="http://techblog.netflix.com/2013/02/rxjava-netflix-api.html" target="_blank" rel="external">Netflix Video Grid</a>。</p>
<p>使用传统的异步回调方式来写API组合代码很快就会把你带进回调地狱。代码将会变得纠缠不清、难以理解也容易出错。更好的方式是使用响应式方法来写声明式风格的API网关代码，比如，响应式抽象包括Scala中的 <a href="http://docs.scala-lang.org/overviews/core/futures.html" target="_blank" rel="external">Future</a> 、Java 8中的<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html" target="_blank" rel="external">CompletableFuture</a> 以及JavaScript中的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="external">Promise</a> ，还有微软为.NET开发的<a href="http://reactivex.io/" target="_blank" rel="external">Reactive Extensions</a> (also called Rx or ReactiveX)， Netflix为了API网关的使用为基于JVM规范创造了RxJava，当然还有为JavaScript创造的RxJS ，可以运行在浏览器和Node.js中。使用响应式风格将会使你写出更简单更高效的API网关代码。</p>
<h2 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h2><p>微服务架构的应用是采用进程间通信的分布式系统，存在两种进程间通讯的方式：一种是采用异步基于消息机制的通信，比如使用消息中介产品 JMS 或者AMQP，当然还有 Zeromq服务直接调用的无中介消息产品；另一种方式是使用HTTP或者Thrift这种同步机制进行通信，一个系统应该同时使用同步和异步风格，甚至为每种方式使用不同的实现，因此，API网关也必须支持这些不同的通信机制。</p>
<h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><p>API网关需要知道和它通信的每个服务的地址（IP地址和端口），在一个传统应用中，你可能硬编码，但在一个流行的，基于云的微服务应用中，这就是一个大问题了。基础架构服务，比如消息中介，通常有一个静态地址，我们可以在系统环境变量中之指定，然而，获取一个应用服务的地址就不是一件简单的事情了，应用服务拥有动态分配的地址，而且，一组服务实例可能因为自动扩展或升级而动态的变化，因此，API网关应该像系统中的其他服务客户端一样，需要服务发现机制：要么是<a href="http://microservices.io/patterns/server-side-discovery.html" target="_blank" rel="external">服务端发现</a> 或者是 <a href="http://microservices.io/patterns/client-side-discovery.html" target="_blank" rel="external">客户端发现</a>。稍后的文章将会详细介绍服务发现的问题，现在，我们有必要意识到，如果系统使用客户端服务发现的话，API网关应该能够查询服务注册 <a href="http://microservices.io/patterns/service-registry.html" target="_blank" rel="external">Service Registry</a>，服务注册是所有服务实例登记其地址的数据库。</p>
<h2 id="处理局部故障"><a href="#处理局部故障" class="headerlink" title="处理局部故障"></a>处理局部故障</h2><p>实现API网关时需要强调的另一个问题是局部故障。这个问题在分布式系统中很常见，比如一个服务可能调用另一个响应很慢或者不可用的服务，API网关千万不要在等待已经挂掉服务响应的时候阻塞。当然，如何处理错误取决于具体的应用场景或者具体因为哪个服务挂掉：比如，如果产品明细场景中的推荐服务挂掉了，那么API网关还是应该返回其他的产品信息，保障产品对用户仍然可以使用，推荐列表可以返回空或者预先硬编码的Top 10商品，但是如果产品信息服务挂掉的话，API网关就要返回客户一个错误了。</p>
<p>API网关如果可能话也可以返回缓存的数据，比如，由于产品价格很少变化，API网关可以在价格服务不可用时使用缓存，数据可能是API网关自己缓存，也可能缓存在诸如Redis和Memcached这样的外部缓存中。通过返回默认值或者缓存值，API网关确保局部故障不会影响用户体验。</p>
<p><a href="https://github.com/Netflix/Hystrix" target="_blank" rel="external">Netflix Hystrix</a>在写调用远端服务代码时候是非常有用的，Hystrix 会标记超过特定阀值的调用为超时，它还实现了断路器模式来阻止更多请求继续调用没有响应的服务，如果一个服务的出错率超过了指定阀值，它会触发断路器，使得所有的请求快速失败一段时间，Hystrix也允许你定义请求失败时的fallback动作 ，比如读取缓存或者返回一个默认值。如果你使用JVM，那么希望你一定考虑使用Hystrix，如果你不使用JVM，那也要有类似的工具来帮助你。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对大多数基于微服务的应用来讲，实现API网关是明智的，API网关就是一个应用的单一入口，它还负责路由请求、组合、协议转换等工作，它为每个应用的客户端提供定制化的API，它也可以通过返回默认值或缓存值来处理失败，下篇文章我们讨论服务间的通信问题。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/04/microservices/Building Microservices-Inter-Process Communication/" itemprop="url">
                  构建微服务之:微服务架构中的进程间通信
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-01-04T13:36:23+08:00" content="2017-01-04">
              2017-01-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/microservice/" itemprop="url" rel="index">
                    <span itemprop="name">microservice</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>原文链接:<a href="https://www.nginx.com/blog/building-microservices-inter-process-communication/?utm_source=introduction-to-microservices&amp;utm_medium=blog&amp;utm_campaign=Microservices" target="_blank" rel="external"><em>Building Microservices: Inter-Process Communication in a Microservices Architecture</em></a></strong></p>
<ol>
<li><em><a href="http://www.jianshu.com/p/8d2cfa1fa633" target="_blank" rel="external">微服务介绍</a></em></li>
<li><em><a href="http://www.jianshu.com/p/9e90b2a5df7b" target="_blank" rel="external">构建微服务之使用API网关</a></em></li>
<li><em>构建微服务之:微服务架构中的进程间通信(本文)</em></li>
<li><em><a href="http://www.jianshu.com/p/1bf9a46efe7a" target="_blank" rel="external">微服务中的服务发现</a></em></li>
<li><em><a href="http://www.jianshu.com/p/9a440c5ea1db" target="_blank" rel="external">微服务之事件驱动的数据管理</a></em></li>
<li><em><a href="http://www.jianshu.com/p/31c2a5a8b764" target="_blank" rel="external">选择一种微服务部署策略</a></em></li>
<li><em><a href="http://www.jianshu.com/p/29f4d788e3bb" target="_blank" rel="external">重构单体应用到微服务</a></em></li>
</ol>
<p>这是使用微服务架构构建应用系列的第三篇文章。第一篇文章介绍了微服务架构模式并讨论了使用微服务的优势和劣势 ；第二篇文章介绍了应用的客户端如何通过API网关作为中介实现服务间的通信；在这篇文章中我们将看一看同一系统间的服务如何通信；第四篇文章主要介绍服务发现的问题。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在传统单体应用中，模块间使用编程语言级别的方法或功能彼此调用。然而微服务架构应用本质上是运行在多台机器上的分布式系统，每个服务都是一个进程！因此，下图为我们展示，微服务必须使用进程间通信（IPC）的机制实现交互：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3912920-f333ee79c1ebd318.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>稍后，我们将看具体的 IPC 技术实现，但首先让我们探讨不同方案设计中的问题。</p>
<h2 id="交互风格"><a href="#交互风格" class="headerlink" title="交互风格"></a>交互风格</h2><p>当我们为服务选择一种IPC机制的时候，我们首先要考虑服务间如何交互，技术上存在多种 client⇔service 交互风格：它们可以按照两大维度分类：第一维度是服务间交互是一对一还是一对多； </p>
<ul>
<li>一对一：每个客户端请求只会被一个服务实例处理。</li>
<li>一对多：每个请求将会被多个服务实例处理</li>
</ul>
<p>第二个维度是交互是同步模式还是异步模式：</p>
<ul>
<li>同步：客户端期望来自服务端的及时响应，甚至可能阻塞并等待。</li>
<li>异步：客户端等待响应时不会阻塞，对异步来讲，及时响应并不是必须的。</li>
</ul>
<p>下列表格展示了两种方式的不同</p>
<p>有下面几种一对一的交互方式：</p>
<ul>
<li>请求/响应模式： 客户端向服务端发送请求并等待响应，并期望服务端可以及时的返回响应。在一个基于线程的应用中，发出请求的线程可能在等待时阻塞线程的执行。</li>
<li>通知（也就是单向请求）：客户端往服务端发送请求，但并不等待响应返回</li>
<li>请求/异步响应：客户端往一个异步返回响应的服务发送请求。客户端等待式并不会阻塞线程，因为设计时就假设请求不会立即返回（js回调）</li>
</ul>
<p>有下面几种一对多的交互方式：</p>
<ul>
<li>发布/订阅模式：客户端发布一个通知消息，消息将会被0或多个感兴趣的服务消费</li>
<li>发布/异步响应：客户端发布一个请求消息，并在一定时间内等待消费消息的服务响应。</li>
</ul>
<p>每个服务通常会使用多种交互风格的组合：对一些服务来讲，简单的IPC机制可能已经足够了，但另外一些服务可能需要几种IPC机制的组合。下图展示了在<strong>taxi-hailing</strong>应用中，当用户请求行程时，服务是如何交互的：<br><img src="http://upload-images.jianshu.io/upload_images/3912920-c46c209a8b21013f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>这个服务使用了通知、请求/响应、发布/订阅风格的组合。比如，乘客使用智能手机向行程管理服务发送一个接送需求的<strong>通知</strong>，行程管理服务将使用<strong>请求/响应</strong>模式调用乘客服务来验证乘客账号是否为活动状态，然后行程管理服务创建行程并使用<strong>发布/订阅</strong>方式来通知诸如分发器（用来定位空闲司机）等服务。</p>
<p>我们已经讨论了交互风格，那么再来看下如何定义API。</p>
<h1 id="定义API"><a href="#定义API" class="headerlink" title="定义API"></a>定义API</h1><p>服务API是服务与客户之间的契约。抛开选择哪种IPC机制的选择，使用一些接口定义语言interface definition language (IDL)准确定义服务API是很重要的！.当然，最好考虑使用API优先的方式来定义服务，通过先写接口定义语言来开始开发，并与客户端开发者（服务消费者）一起review你的设计，先对API定义进行迭代，再去实现这些服务。这样做设计的话将会使你构建更加符合客户需求的服务！</p>
<p>后续文章你将会发现，服务定义和你选择哪种IPC机制息息相关，如果你是要消息机制，API就由消息频道和消息类型组成；如果你使用http，API就是由URLs以及request/response格式组成。稍后我们将会讨论更多关于接口定义语言的细节。</p>
<h2 id="API进化"><a href="#API进化" class="headerlink" title="API进化"></a>API进化</h2><p>服务API将会不可避免的随着时间进化，在传统单体应用中，我们可以很直接的去修改服务并更新所有服务的调用者（refactor）。但是在基于微服务架构的应用中，哪怕服务API的其他消费者都是在一个应用中，去更新所有服务也是相当困难的。你通常不能强制让所有的客户端升级来保持和服务端升级维持步调一致，而且，你还可能会增量部署新服务使得新老服务同时运行，寻找一种处理此种情况的策略是很重要的。</p>
<p>你是如何根据更改的大小来处理服务API的变化的呢？一些变化很小，通常可以与之前版本做到向后兼容，比如，你为请求或相应添加了一个属性；对此，设计服务时考虑服务和客户消费者的鲁棒性原则是很有必要的：使用就版本服务API的客户端可以在新版本服务API下正常工作，服务端为客户端缺失的属性提供默认值，客户端自动忽略额外添加的响应属性。最后强调，注意使用IPC机制和定义消息格式使你的API可以简单方便的进化！</p>
<p>当然，有时候我们不得不对API做一些较大的，不再兼容的变化，而我们这时候又不可能强制每个客户端升级，因此我们的服务就要继续支持运行一段时间的老版本API。如果使用http，我们可以在URL里嵌入服务版本，每个服务实例可能同时处理多个版本的服务，当然，你也可以选择为每个服务版本部署单独的服务实例。</p>
<h2 id="处理局部故障"><a href="#处理局部故障" class="headerlink" title="处理局部故障"></a>处理局部故障</h2><p>就像前面关于API网关文章提到的那样：在分布式系统中总会有无时无刻的局部故障的风险。由于客户端和服务在不同的进程中，服务可能由于挂掉或者维护原因而不能及时响应客户端的请求，或者服务由于过载原因导致响应缓慢。</p>
<p>比如，让我们考虑之前文章提到的<strong>Product details</strong>场景，假设推荐服务没有响应了，一个简单的客户端实现可能无期限的等待服务响应并阻塞，这样不仅导致糟糕的用户体验，在很多应用中还会消耗比如线程这样宝贵的资源，最终就像下图展示的那样，运行时将会用尽所有线程使得服务不再响应任何请求：<br><img src="http://upload-images.jianshu.io/upload_images/3912920-11c7d11329b92789.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>为解决此类问题，设计上处理局部故障是很有必要的。</p>
<p>Netflix给出了一些处理局部故障比较好的方法：</p>
<ul>
<li>网络超时：等待响应时不要一直阻塞，而是使用超时，超时能够保证资源不会一直被占用</li>
<li>限制未完成请求的数量：针对一个请求某服务的客户端，需要设置其未处理请求数量的上限，一旦超过限制就不再处理任何请求，这样就做到快速失败。</li>
<li>断路器模式：跟踪成功和失败请求的数量，如果比率超过了设置的阀值，打开断路器使得后续请求快速失败。如果大量请求失败，就建议服务为不可以状态并决绝处理新请求，过一段时间之后，客户端可以再次重试，一旦成功，关闭断路器。</li>
<li>提供fallback机制：请求失败时提供fallback，比如返回缓存值或者为失败的推荐服务返回默认空集合作为默认值。<br><strong>Netflix Hystrix</strong>是一个实现了这些模式的开源工具包，如果你使用JVM那么一定要考虑使用它！如果你的服务不是运行在JVM中，那也要考虑有等效的实现来处理此类问题。</li>
</ul>
<h2 id="IPC-技术"><a href="#IPC-技术" class="headerlink" title="IPC 技术"></a>IPC 技术</h2><p>我们有不同的IPC技术可供选择：服务可以使用基于请求/响应的同步通信模式，比如基于Http的REST或者Thrift，当然，也可以使用异步基于消息的通信模式，比如AMQP、STOMP。这些通信模式有不同的消息格式，服务可以使用基于文本格式、方便阅读的JSON 或者 XML格式，也可以使用效率更高的二进制格式（比如Avro或Protocol Buffers）。稍后我们将讨论同步IPC机制，现在我们先讨论下异步的IPC机制：</p>
<h3 id="异步，基于消息的通信"><a href="#异步，基于消息的通信" class="headerlink" title="异步，基于消息的通信"></a>异步，基于消息的通信</h3><p>使用消息时，进程间通过异步交换消息来通信。一个客户端通过发送消息的方式请求服务，如果期望服务有响应，也是服务通过向客户端发送另外的消息来实现。由于通信是异步的，客户端不会为了响应等待并阻塞，相反的，客户端编程时就是以服务不会立即返回响应来处理的。</p>
<p>一条消息包含消息头（元数据和发送者）和消息体，消息通过频道进行交换，任意数量的消费者都可以往频道中发消息，任意数量的消费者也可以消费频道中的消息。有<strong>point‑to‑point</strong>和<strong>publish‑subscribe</strong>两种频道：point‑to‑point模式下，频道的消息只会被交付到某一个消费者，这种模式用于前面提到的一对一的交互；publish‑subscribe 模式下，频道的消息将会交付到所有感兴趣的消费者，使用于前面提到的一对多交互风格。</p>
<p>下图展示了<strong>taxi-hailing</strong> 应用可能是一publish-subscribe模式：<br><img src="http://upload-images.jianshu.io/upload_images/3912920-6cb0d76a907b6ec2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>行程管理服务通过向publish-subscribe频道写入trip create消息的方式通知比如分发器这样感兴趣的服务，分发器查找空闲司机并通过向publish-subscribe频道写入Driver Proposed消息通知其他服务。</p>
<p>有多种消息系统供我们选择，当然我们尽量选择一个支持多种编程语言的来使用。一些消息系统支持标准的协议比如 AMQP和STOMP，另一些消息系统有专有但是文档化的协议，大量的开源消息系统可供我们挑选，包括RabbitMQ、Apache Kafka、Apache ActiveMQ和NSQ。统一的来看，他们都支持某种形式的消息和频道，都致力于高可靠，高性能和高扩展性，但是每个消息中介在实现细节上还是有很大的不同：<br>使用消息系统有很多优点：</p>
<ul>
<li>客户端与服务端解耦： 客户端只需要向合适的频道发送消息就实现简单的请求，客户端完全感知不到服务实例的存在，因此不需要再去使用一套服务发现机制去决定服务实例的位置。</li>
<li>缓存消息：在同步的请求/响应协议，比如HTTP下，客户端和服务端在交互的阶段必须保证双方都可用，然而，消息中介会把消息写入队列直到消息被消费者处理位置，这意味着，尽管 在订单履行系统响应缓慢甚至不可用情况下，在线商城仍然可以接受来自客户的订单，只需要先把订单消息简单的入队即可。</li>
<li>灵活的客户-服务端交换风格，消息支持前面提到的所有交互风格。</li>
<li>显示的进程间通信：基于 RPC的通信机制试图使调用远程服务等同于调用本地服务。然而，由于物理定律和局部故障的可能性，事实上他们相当不同。消息使这些差异非常明显，因此开发人员不被虚假的安全感所迷惑。</li>
</ul>
<p>当然消息系统也有缺点：</p>
<ul>
<li>额外的运维复杂度：消息系统毕竟也是额外的系统组件，也要求安装、配置、运维等操作，有必要保证消息系统的高可用，否则会影响整个系统的稳定性。</li>
<li>实现请求/响应交互的复杂度：要实现请求/响应的交互风格还是要做些额外工作的：每条请求消息必要要包含回复频道的标志符以及关联标志符 ，服务回写包含关联ID的消息到回复频道，客户端使用关联ID去匹配请求对应的响应。当然，如果使用直接支持请求/响应的基于IPC机制的方式，将会特别简单。</li>
</ul>
<p>我们已经讨论了基于消息的IPC，再看检验下基于请求/响应的IPC吧：</p>
<h3 id="同步，基于请求-响应的IPC"><a href="#同步，基于请求-响应的IPC" class="headerlink" title="同步，基于请求/响应的IPC"></a>同步，基于请求/响应的IPC</h3><p>当使用同步，基于请求/响应的IPC机制的时候，客户端向服务端发送请求，服务端处理请求并返回响应，很多客户端，发出请求的线程会在等待响应过程中阻塞，另外有一些客户端也会使用异步、事件驱动的代码，比如封装好的Futures 或 Rx Observables。然而，和使用消息不一样，客户端假设请求会立即返回。有几种方案供我们选择，比较流行就是REST和 Thrift，我们先看下REST：</p>
<h4 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h4><p>限制使用REST风格暴露API很流行，REST基本就是使用HTTP的IPC 机制，REST的关键理念是资源，也就是通常代表诸如用户或产品的某个或一组业务对象，REST使用HTTP verbs维护URL指向的资源，比如 GET返回某资源的表示，可能是XML也可能是JSON对象， POST会创建新资源，PUT更新资源··· 引用自Roy Fielding，提出REST的大牛：</p>
<p>“REST provides a set of architectural constraints that, when applied as a whole, emphasizes scalability of component interactions, generality of interfaces, independent deployment of components, and intermediary components to reduce interaction latency, enforce security, and encapsulate legacy systems.”<br>—Fielding, <a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm" target="_blank" rel="external">Architectural Styles and the Design of Network-based Software Architectures</a></p>
<p>下图展示了<strong>taxi-hailing </strong>应用使用REST的场景：<br><img src="http://upload-images.jianshu.io/upload_images/3912920-f0467101397a961a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>乘客向行程服务/trips发送POST请求，行程服务通过向乘客管理服务发送GET请求获取乘客信息，在验证完乘客授权之后，创建行程，行程服务创建行程后返回201响应给手机.</p>
<p>很多用了HTTP暴露服务API的开发就说自己是REST，其实按照 Fielding 在<a href="http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven" target="_blank" rel="external">blog post</a>描述的规定，他们根本不是REST。 Leonard Richardson (no relation)定义了非常有用的 <a href="http://martinfowler.com/articles/richardsonMaturityModel.html" target="_blank" rel="external">maturity model for REST</a>组成了下面几个级别：</p>
<ul>
<li>Level 0 :客户端使用HTTP POST调用服务固定的URL，每次请求指定动作和参数</li>
<li>Level 1：支持资源的概念，请求通过POST，并且要制定要做的动作和参数</li>
<li>Level 2：充分使用 HTTP verbs 执行动作GET获取资源 POST创建资源PUT更新资源，还是要请求参数和请求体，还可以指定请求的参数，使得服务充分使用web基础架构的功能，比如缓存请求等</li>
<li>Level 3:  API定义按照HATEOAS (Hypertext As The Engine Of Application State) 原则。基本的定义就是GET请求返回表示资源的body中包含一些对资源允许动作的链接。比如，客户端可以使用get订单返回的订单body中的一个超链接取消一个订单。HATEOAS 优点之一是：客户端不用在代码中硬编码URL了，另外，由于返回的body中包含允许对资源所作动作的超链接，客户端就不需要再猜测当前资源状态下他可以做哪些操作了。</li>
</ul>
<p>使用基于HTTP的协议的优点有：</p>
<ul>
<li>HTTP 简单而且大家都熟悉</li>
<li>可以用浏览器测试，配合比如Postman插件更佳，命令行curl也很方便（假设使用json或其他数据格式）</li>
<li>直接就支持请求/响应风格的通信</li>
<li>HTTP很友好</li>
<li>无需中介，简化架构</li>
</ul>
<p>使用HTTP的缺点：</p>
<ul>
<li>HTTP只支持请求/响应风格的交互，你可以使用HTTP请求向服务器发送通知，但是服务器一定要返回HTTP响应。</li>
<li>客户端和服务端没有消息buffer机制，交互都是直接的，这就要求交换消息的时候双方必须同时运行。</li>
<li>客户端必须知道每个服务实例的地址，比如URL，正如前面的API网关文章描述的那样，在现代流行的应用架构中，这已经不再是一个问题，我们可以使用服务发现机制来定位服务实例。</li>
</ul>
<p>开发者论坛最近又重新发掘了RESTful API风格接口定义语言的价值，我们可以选择使用<strong>RAML</strong>或者<strong>Swagger</strong>等工具， Swagger允许定义请求响应的消息格式，RAML则要求你使用额外的诸如JSON Schema这样的定义.IDL除了描述API，通常还会提供根据接口定义生产客户端Stub或服务端骨架的工具。</p>
<h2 id="Thrift"><a href="#Thrift" class="headerlink" title="Thrift"></a>Thrift</h2><p><strong>Apache Thrift</strong>是REST的一个很有意思的替代品，它是一个实现跨语言客户端与服务端RPC通信的框架。Thrift提供C语言风格的接口定义语言来定义API，你可以通过编译生成客户端Stub和服务端的骨架，编译器可以为 C++、Java、Python、PHP、Ruby、Erlang、Node.js等不同语言生产代码。</p>
<p>一个Thrift接口包含一个或多个服务，一个服务定义可以类比java的接口：都是一组强类型方法的集合。Thrift方法可以返回值也可以被定义为单向通信，如果方法需要返回值就需要实现请求/响应风格的交互，客户端等待响应的时候可能会抛出异常；单向通信就是我们前面讲到的通知风格的交互，服务端不需要返回响应。</p>
<p>Thrift支持不同的消息格式：JSON、binary以及compact binary。 Binary相对JSON更加高效，因为解码速度更快，compact binary比JSON空间利用率高，见名知意嘛，JSON则对人和浏览器更加的友好 ；Thrift也支持不同的通信协议选择：原生TCP或者HTTP，原生TCP相比HTTP肯定更加高效，但是HTTP对防火墙、人以及浏览器更加的友好。</p>
<h2 id="消息格式"><a href="#消息格式" class="headerlink" title="消息格式"></a>消息格式</h2><p>既然我们已经讨论了HTTP和Thrift，现在再来探讨下消息格式的问题吧：如果你需要消息系统或者REST风格交互，你就必须选择消息格式。其他类似Thrift的IPC机制可能只支持一小部分的消息格式，甚至只会支持一种！在某些情况下，使用一种支持跨语言的消息格式非常重要，哪怕你现在只有一种语言实现微服务，谁又能保证你以后不会使用新的语言呢？</p>
<p>主要有文本和二进制两种格式：文本格式包括JSON和XML等，文本格式不仅仅方便阅读，而且是自描述的，JOSN中对象属性是采用一组键值对的组合来表示的；同样，XML的属性是采用命名元素和值来表示的，这样允许消费者只挑选感兴趣的消息摒弃其他消息，因而这种方式也可以方便的做到向后兼容。</p>
<p>XML文档的结构是由XML schema来指定的，随着时间的流逝，开发者论坛逐步意识到JSON也需要类似的机制：一种选择是使用JSON Schema，要么单独使用，要么作为类似Swagger这种IDL的一部分使用。</p>
<p>文本格式消息的缺点是非常的冗长，尤其是XML格式：由于消息是自描述的，每条消息除了值之外还包含属性的名称，另一个缺点就是解析文本开销略大，这时候可以考虑下二进制格式。</p>
<p>二进制格式也有多种选择：如果使用Thrift，你可以选择Thrift binary，如果选择其他的消息格式，比较流行的还有Protocol Buffers和Apache Avro，两种格式都提供了IDL来定义消息的结构。区别是，Protocol Buffers使用标记字段，而Avro 消费者则需要了解Schema才能解析消息，因此使用Protocol Buffers时，API进化比Avro更容易。这篇 <a href="http://martin.kleppmann.com/2012/12/05/schema-evolution-in-avro-protocol-buffers-thrift.html" target="_blank" rel="external">文章</a>是一个对Thrift、 Protocol Buffers以及 Avro非常好的比较。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>微服务需要使用进程间通信的机制进行交互，当设计你的服务如何通信的时候，需要考虑多个问题：服务如何交互、如何为服务定义API、如何处理API进化、如何处理局部故障。有两种微服务可以使用的IPC机制：异步消息和同步的请求/响应。该系列的下一篇文章，将会讲解微服务架构中的服务发现问题。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/15/learning/distributeSystem/" itemprop="url">
                  学习笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-11-15T17:21:55+08:00" content="2016-11-15">
              2016-11-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/learning/" itemprop="url" rel="index">
                    <span itemprop="name">learning</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>###<br><a href="http://nosqldb.org/p/5458e2aeb7619ae04486b7aa" target="_blank" rel="external">Facebook Haystack Image storage</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/13/JavaScript/You-Dont-Know-JS-Scope&Closures/" itemprop="url">
                  You Don't Know JS - Scope & Closures
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-10-13T15:21:55+08:00" content="2016-10-13">
              2016-10-13
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>最近开始You Don’t Know JS系列书籍，必然先从Scope和Closure这部分搞起,作为一个水水的javascript写手，还是希望多深入下的，啃这本书，精简总结下吧。</p>
</blockquote>
<h2 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h2><blockquote>
<p>几乎所有编程语言的基础功能是将数值存储到变量之中，稍后获取或者修改值。存储值从变量中拿出的功能给予语言存储 <strong>状态state</strong>。我们比较关心的问题是： 这些变量存储在哪里呢？ 最重要的是，程序又是如何在需要的时候找到这些变量的呢？</p>
</blockquote>
<p><code>定义一组规则将变量存储到某处，规定好如何获取这些变量的值，这些规则集合就是我们的主角之一：Scope</code></p>
<h4 id="Scope-1"><a href="#Scope-1" class="headerlink" title="Scope"></a>Scope</h4><ul>
<li>Engine ：负责js的编译和执行</li>
<li>Compiler： Engine的好朋友，负责一些脏活累活，比如语法分析词法分析AST的生成</li>
<li><p>Scope：Engine的另一个好朋友，负责收集和维护一个有关变量（包括方法的）查询列表，并定义一个规范集合去规定在代码执行阶段的变量存取方式</p>
<p>var a = 2<br>很多人估计和我一样是这么理解这句话的：为一个变量分配内存，并标记为a，之后把值2存储到a中。<br>然而事实上在js中并非如此：</p>
<ul>
<li>编译器碰到变量a，Compiler询问<code>特定</code>Scope的集合中是否存在变量a，不存在就创建一个，存在的话Compiler就忽略继续</li>
<li>Compiler将会generate code为Engine运行代码做准备，运行时刻才会执行a=2(assignment)，code engine 在执行的时候会先查看当前scope的集合中是否存在a，如果有就拿出来，没有的话继续查找(nest scope) 找到a再赋值2给它，找到顶 找不到就报错</li>
</ul>
</li>
</ul>
<p><strong>也就是说声明和赋值是两个步骤，而且声明在编译阶段，赋值在执行阶段</strong></p>
<h4 id="赋值表达式"><a href="#赋值表达式" class="headerlink" title="赋值表达式"></a>赋值表达式</h4><ul>
<li>LHS<pre><code>a= 2 ;//Scope中先查找定义 再执行复制
</code></pre></li>
<li>RHS  <pre><code>console.log(a);//Scope中查询值
</code></pre></li>
</ul>
<h4 id="Nested-Scope"><a href="#Nested-Scope" class="headerlink" title="Nested Scope"></a>Nested Scope</h4><p>   类比楼梯中找东西 第一层找不到找第二次，逐层上移，直到顶层找不到，报错</p>
<ul>
<li>ReferenceError  找到楼房顶端了还是找不到</li>
<li>TypeError  找到了，但是还没赋值</li>
</ul>
<h4 id="Lexical-Scope"><a href="#Lexical-Scope" class="headerlink" title="Lexical Scope"></a>Lexical Scope</h4><p><img src="/images/js/scope.png" alt="气泡解释scope "><br>lexical scope 是在方法声明的时候被定义的，也就是说变量所在的scope在写代码的时候就已经确认了,变量的查找规则就像上图所示，但是并不是仅仅只有lexical scope,js也存在其他几种方法对scope进行欺骗 cheating lexical (eval and )</p>
<h5 id="Lexical-Cheating"><a href="#Lexical-Cheating" class="headerlink" title="Lexical Cheating"></a>Lexical Cheating</h5><ul>
<li>eval<pre><code>function foo(str,a){
  eval(str);//cheated, b=3 will shadow b=2
  console.log(a,b);
}
var b = 2;
foo(&quot;var b = 3;&quot;,1);//1,3
</code></pre></li>
<li>eval under strict mode<pre><code>function foo(str){
  &quot;use strict&quot;;
   eval(str);
   console.log(a);//ReferenceError: a is not defined       
}
foo(&quot;var a = 2;&quot;);
</code></pre>eval 在严格模式下只会执行但是不会改变eclosing scope<br><code>尽量在代码中避免eval的使用</code></li>
<li>with<pre><code>function foo(obj){
  with(obj){
    a = 2;
  }
}
var o1 = { a:3 };
var o2 = { b:3 };
foo(o1);
console.log(o1.a);//2
foo(o2);
console.log(o2.a);//undefined
console.log(a);//2, Leaked global
</code></pre>eval会修改当前的scope 而with会创建一个新的lexical scope</li>
<li>性能问题 ： 正常情况下采用lexical scope，js的编译器会帮助我们优化代码，提升sope执行过程中查找变量的速度（scopo在写代码的时候就已经定了），但是一旦代码中加入了eval,编译器就会认为运行过程会改变scope，因此根本不会进行代码的优化，性能下降</li>
</ul>
<h2 id="Closure"><a href="#Closure" class="headerlink" title="Closure"></a>Closure</h2><h4 id="Closure-1"><a href="#Closure-1" class="headerlink" title="Closure"></a>Closure</h4>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/katana.jpg"
               alt="steven xu" />
          <p class="site-author-name" itemprop="name">steven xu</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">25</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">categories</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">steven xu</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  



  




  
  

  

  

  

</body>
</html>
